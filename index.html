<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="starslight">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">starslight</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/23/%E5%A5%97%E8%B7%AF%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="starslight">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/23/%E5%A5%97%E8%B7%AF%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">套路题目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-03-23 00:00:00 / Modified: 22:43:02" itemprop="dateCreated datePublished" datetime="2023-03-23T00:00:00+08:00">2023-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="树">树</h1>
<h3 id="思维技巧">思维技巧</h3>
<ol type="1">
<li><p>将树上所有到从 <span class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的路径的距离不超过$ d <span
class="math inline">\(的点的点权加上\)</span> k$，单点询问</p>
<blockquote>
<p>再链上，边<span class="math inline">\(u\rightarrow
v\)</span>，距离<span class="math inline">\(v\)</span>,为<span
class="math inline">\(k-1\)</span>的被距离<span
class="math inline">\(u\)</span>，为<span
class="math inline">\(k\)</span>的覆盖，所以只用考虑距离每个点子树内恰好为<span
class="math inline">\(k\)</span>，继续树上差分，开d颗树状数组，<span
class="math inline">\(bit[k][out[u]]-bit[k][in[u]-1]\)</span>表示给<span
class="math inline">\(u\)</span>的深度k加上这个值，然后考虑从<span
class="math inline">\(lca\)</span>向上走的贡献，记录<span
class="math inline">\(f[u][dis]\)</span>表示<span
class="math inline">\(u\)</span>对子树内距离不超过<span
class="math inline">\(dis\)</span>加的值，再删除<span
class="math inline">\(f[fa[u]][dis-2]\)</span>，在<span
class="math inline">\(x\)</span>跳<span
class="math inline">\(fa\)</span>的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ri i=<span class="number">0</span>;i&lt;=<span class="number">20</span>&amp;&amp;x;i++) &#123;</span><br><span class="line">	res+=fen[i].<span class="built_in">rangequery</span>(in[x],out[x]);</span><br><span class="line">	<span class="keyword">for</span>(ri j=dis;j&lt;=<span class="number">20</span>;j++)res+=f[x][j];</span><br><span class="line">	++dis;</span><br><span class="line"> 	x=father[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可</p>
</blockquote></li>
<li><p>$u $到 $v $的简单路径上的所有点点权异或和 <span
class="math inline">\(=0\)</span> (<span
class="math inline">\(CF1709E\)</span>)</p>
<blockquote>
<p>令 <span class="math inline">\(au\)</span> 表示 <span
class="math inline">\(u\)</span> 的点权，<span
class="math inline">\(du\)</span> 表示树上 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(u\)</span> 简单路径上所有点的点权异或和。</p>
<p>等价于 <span
class="math inline">\(du⊕dv⊕alca(u,v)=0\)</span>，然后考虑只修改<span
class="math inline">\(alca(u,v)\)</span>就可以了</p>
</blockquote></li>
<li><p>多次考虑一颗子树的贡献，那么可以转化成一个点对其到根的链上的点的贡献(<span
class="math inline">\(P3925\)</span>)</p></li>
<li><p>一条边两端的选点问题<span
class="math inline">\(\rightarrow\)</span>边与点配对</p></li>
<li><p>树上<span class="math inline">\(LIS\)</span>问题</p>
<blockquote>
<p>参考<span class="math inline">\(CF490F\)</span></p>
</blockquote></li>
<li><p>一棵树的直径的中点唯一</p></li>
<li><p>树上联通合并的时候，新的连通块直径只能是<span
class="math inline">\(4\)</span>个端点中的两个</p></li>
<li><p>求子树外，倍增<span
class="math inline">\(dfn\)</span>序列，那么就是连续区间了。</p></li>
<li><p>节点带颜色，考虑动态开点或者总共<span
class="math inline">\(O(n)\)</span>的算法或数据结构</p></li>
<li><p>树上贪心：一般从叶子节点开始贪心，才能保证最优。</p></li>
</ol>
<h1 id="图论">图论</h1>
<h3 id="最短路">最短路</h3>
<ol type="1">
<li><strong>两点间最短路径是简单路径，不会有环路</strong> (<span
class="math inline">\(SCOI2009\)</span>最长路径)</li>
<li>求两个环之间长度的差值，正向边<span
class="math inline">\(1\)</span>，反向边<span
class="math inline">\(-1\)</span>，(<span
class="math inline">\(NOI2008\)</span>假面舞会)</li>
<li></li>
</ol>
<h3 id="图论模型转化">图论(模型)转化</h3>
<ol type="1">
<li><p>$ ∑<em>{i∈E}w_i−max</em>{⁡i∈E}w_i+min⁡{i∈E}w_i$</p>
<blockquote>
<p>权值最大不计数，权值最小双计数，问最短距离。</p>
<p>跑分层图</p>
</blockquote></li>
<li></li>
</ol>
<h3 id="优化建图">优化建图</h3>
<ol type="1">
<li>有关<span
class="math inline">\(GCD\)</span>或者倍数关系的建图，一定要往完全图<span
class="math inline">\(\rightarrow\)</span>树的方向想，例如说：两两<span
class="math inline">\(gcd=a\)</span>的连边，那么可以，<span
class="math inline">\(a\rightarrow 2\times a,a\rightarrow 3 \times a
....\)</span>连边，连通性一定满足，大小为<span
class="math inline">\(O(nlogn)\)</span></li>
</ol>
<h3 id="杂项">杂项</h3>
<ol type="1">
<li><p>完全图<span
class="math inline">\(\rightarrow\)</span>补图</p></li>
<li><p>奇环套奇环不可能生成奇环</p></li>
<li><p>“存在一个” 一定要想着转换成 <span
class="math inline">\(\rightarrow\)</span> “不存在，对于所有” (<span
class="math inline">\(CF1517F\)</span>)</p>
<blockquote>
<p>本质上是存在性问题转化成限制问题</p>
</blockquote></li>
<li></li>
</ol>
<h3 id="二分图">二分图</h3>
<ol type="1">
<li><p>二分图小优化：每次如果没有发现一个可行的匹配，那么就不清空 <span
class="math inline">\(vis\)</span> 数组</p>
<blockquote>
<p>下一次走到这里还是不匹配</p>
</blockquote></li>
<li><p>若一条边一定在最大匹配中，则在最终的残量网络中，这条边一定满流，且这条边的两个顶点一定不在同一个强连通分量中。（
<span class="math inline">\(HAOI2017新型城市化\)</span>)</p></li>
<li><p>无向图是不能用网络流求最小路径覆盖的。</p></li>
<li><p>带权二分图匹配<span
class="math inline">\(\rightarrow\)</span>不带权 (<span
class="math inline">\(CF1728F\)</span>)</p></li>
<li><p>并查集判断二分图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">findf</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == f[x])  <span class="keyword">return</span> <span class="built_in">make_pair</span>(x, <span class="number">0</span>);</span><br><span class="line">    pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ls = <span class="built_in">findf</span>(f[x]);</span><br><span class="line">    ls.second ^= g[x];</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ls;</span><br><span class="line">    ls = <span class="built_in">findf</span>(x);  </span><br><span class="line">    op ^= ls.second;</span><br><span class="line">    x = ls.first;</span><br><span class="line">    </span><br><span class="line">    ls = <span class="built_in">findf</span>(y);</span><br><span class="line">    op ^= ls.second;</span><br><span class="line">    y = ls.first;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> op == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sze[x] &lt; sze[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    sze[x] += sze[y];</span><br><span class="line">    f[y] = x;</span><br><span class="line">    g[y] = op;</span><br><span class="line">    del[++cnt] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二分图最小字典序匹配通解：(<span
class="math inline">\(P1963\)</span>)</p>
<blockquote>
<p>注意倒着匹配是会出问题的，只有在度数为2的时候才正确。</p>
</blockquote>
<p><img src="E:\3_disk_c\pics\1_3.png" alt="1_3" style="zoom: 67%;" /></p>
<blockquote>
<p>所以正确的通解是这样的：</p>
<p>方法2：从前往后枚举，对于每一个点，从小到大假设它与谁匹配，如果它匹配后剩下的图仍能构成</p>
<p>​ 完美匹配，就说明它可以与当前儿子匹配，删掉这个点与其匹配点。</p>
<p>方法3：在算法 <span class="math inline">\(2\)</span>
中，每假设当前点<span class="math inline">\(x\)</span>与某个点 <span
class="math inline">\(y\)</span>
匹配，就要对整个图跑一次二分图匹配，但实际上</p>
<p>​
大多点在这次匹配操作后是没有影响的。所以我们可以先在开始时对整个图跑一次二分图匹</p>
<p>​ 配。经过分析，我们可以发现把 <span class="math inline">\(x\)</span>
与 $y $匹配只会影响两个点：目前与 <span class="math inline">\(x\)</span>
匹配的点与目前与 <span class="math inline">\(y\)</span></p>
<p>​
匹配的点。所以每次只用对影响的这两个点中的任意一个点跑一次增广路就可以了</p>
</blockquote></li>
<li></li>
</ol>
<h3 id="生成树">生成树</h3>
<ol type="1">
<li>有向图的最小生成树？按照高度为第一关键字，距离为第二关键字即可
(<span class="math inline">\(SCOI2012\)</span>滑雪)</li>
</ol>
<h1 id="动态规划dp">动态规划DP</h1>
<p>参见<span class="math inline">\(DP\)</span>科技树</p>
<h1 id="序列liner">序列liner</h1>
<ol type="1">
<li><p>一些数，自选操作，问结果的和 (<span
class="math inline">\(CF1743F\)</span>)</p>
<blockquote>
<p>单点贡献法，考虑每一种数，会对哪些结果产生影响</p>
</blockquote></li>
<li><p>给一些线段，问点<span class="math inline">\(1\rightarrow
n\)</span>分别被哪些线段覆盖(<span
class="math inline">\(CF1743F\)</span>)</p>
<blockquote>
<p><span class="math inline">\(x\rightarrow
x+1\)</span>的过程，只会影响右端点在<span
class="math inline">\(x\)</span>，左端点在<span
class="math inline">\(x+1\)</span>的情况，每个线段被修改2次</p>
</blockquote></li>
<li><p><span class="math inline">\(n\)</span>对数,<span
class="math inline">\((a_i,b_i)\)</span>，每一对数要么选<span
class="math inline">\(a_i\)</span>要么选<span
class="math inline">\(b_i\)</span>，问总共选<span
class="math inline">\(k\)</span>个<span
class="math inline">\(a_i\)</span>，<span
class="math inline">\(n-k\)</span>个<span
class="math inline">\(b_i\)</span>的最大值，<span
class="math inline">\(k\in[0,n]\)</span>（<span
class="math inline">\(CF1728E\)</span>)</p>
<blockquote>
<p>先选<span class="math inline">\(n\)</span>个<span
class="math inline">\(b_i\)</span>，再加上堆里恰好<span
class="math inline">\(k\)</span>个最大的<span
class="math inline">\(a_i-b_i\)</span>，<span
class="math inline">\(O(n)\)</span></p>
</blockquote></li>
<li><p>两个集合<span class="math inline">\(A,B\)</span>，<span
class="math inline">\(A与B\)</span>一一对应，<span
class="math inline">\(A\)</span>无序，<span
class="math inline">\(B\)</span>要求有序，则可以不管<span
class="math inline">\(B\)</span>的顺序，求完后再给<span
class="math inline">\(B\)</span>排序就行。(<span
class="math inline">\(CF1728F\)</span>)</p></li>
<li><p>有 <span class="math inline">\(n+1\)</span> 个传送器，分别位于
<span class="math inline">\(0,a_1,a_2,⋯,a_n\)</span>，可以从点 <span
class="math inline">\(x\)</span> 传送到 <span
class="math inline">\(y\)</span>，并且花费<span
class="math inline">\((y-x)^2\)</span>，再整点安装额外传送器使得可以从
<span class="math inline">\(0\)</span>传送到 <span
class="math inline">\(a_n\)</span> 且花费少于 <span
class="math inline">\(m\)</span>。最小化这个安装数量。(<span
class="math inline">\(CF1661F\)</span>)</p>
<blockquote>
<p><span class="math inline">\(f(x,k)\)</span> 表示将长度为 <span
class="math inline">\(x\)</span> 的段分为 <span
class="math inline">\(k\)</span> 段所需的最小费用，有结论：</p>
<p><span class="math inline">\(∀k∈[1,x]\)</span>，都有
$f(x,k−1)−f(x,k)≥f(x,k)−f(k+1) $</p>
</blockquote></li>
<li><p><font color='red'><strong>最少能删除几个<span
class="math inline">\(\rightarrow\)</span>最大能保留多少</strong></font></p></li>
<li><p><font color='red'><strong>多个数取不同模的时候，可以想想所有模数的LCM，找找性质(<span
class="math inline">\(CF498D\)</span>)</strong></font></p></li>
<li><p><font color='red'><span
class="math inline">\(max^{k≤r}_{k=l}a_k\)</span>，想到<span
class="math inline">\(\rightarrow\)</span>单调队列，意义在于：找到左边右边第一个大于<span
class="math inline">\(a_k\)</span>的数字(<span
class="math inline">\(CF1677E\)</span>)</font></p></li>
<li><p><font color='red'><strong><span class="math inline">\(q\)</span>
次询问，每次给出 <span class="math inline">\(l,r\)</span>，问有多少个
<span class="math inline">\(i,j\)</span> 满足 <span
class="math inline">\(l≤i≤j≤r\)</span>且区间 <span
class="math inline">\([i,j]\)</span> 是好的</strong></font></p>
<blockquote>
<p>离线下来扫描线，具体的，设当前枚举右端点为 <span
class="math inline">\(r\)</span>，那么 <span
class="math inline">\(s_l\)</span> 是 <span
class="math inline">\([l,l],[l,l+1],...,[l,r]\)</span>里好的区间的数目。这样当
<span class="math inline">\(r=R\)</span> 时，直接求当前 <span
class="math inline">\(s_L+...+s_R\)</span>，就是询问 <span
class="math inline">\([L,R]\)</span> 的答案。</p>
</blockquote></li>
<li><p>集合内<span
class="math inline">\(DP\)</span>，但无法记录仪当前已经用过的数的状况，考虑连通块<span
class="math inline">\(DP\)</span>（<span
class="math inline">\(CF840C\)</span>)</p></li>
<li><p>给定<span class="math inline">\(n\)</span>个数，<span
class="math inline">\(a_1,a_2,a_3...\)</span>，每次选定任意<span
class="math inline">\(k\)</span>个数<span
class="math inline">\(-1\)</span>，最后变成全<span
class="math inline">\(0\)</span>，那么只要满足<span
class="math inline">\(max(a_i)\le
\frac{sum}{k}\)</span>，具体可用数学归纳法证明。</p></li>
<li><p>极差最小化？<span class="math inline">\(\rightarrow\)</span>
双指针（<span class="math inline">\(CF1574E\)</span>)</p></li>
<li><p>相互限制问题，可以转化成拓扑<span
class="math inline">\(top\)</span>排序</p></li>
<li><p>涉及到前缀和计数的题目，往<span
class="math inline">\(trie\)</span>树和子树关系上面去思考</p></li>
<li><p>如果多次询问划开了原来的分组方式，可以考虑每个点可以拓展的区间，再区间求<span
class="math inline">\(max\)</span>或者取<span
class="math inline">\(min\)</span>以达到多次询问在线反应的效果 (<span
class="math inline">\(CF1516D\)</span>)</p></li>
<li><p><font color='red'>问一个区间多少种数？<strong>HH的项链</strong>，而且树状数组大小<strong>不是值域！！！是<span
class="math inline">\(n\)</span>！！！</strong> (<span
class="math inline">\(CF980D\)</span>)</font></p></li>
<li><p>序列而且两两交换，不好<span
class="math inline">\(DP\)</span>，可以考虑<strong>置换群</strong>
(<span class="math inline">\(CF441D\)</span>)</p></li>
<li><p>快速计算当前连通块个数，每次合并如果成功则<span
class="math inline">\(N--\)</span>，否则<span
class="math inline">\(N\)</span>不变。(<span
class="math inline">\(CF1039C\)</span>)</p></li>
<li><p>若干区间，单点<span
class="math inline">\(+1\)</span>，问哪些区间在哪些时刻达到<span
class="math inline">\(a[i].k\)</span> (<span
class="math inline">\(CF\)</span> <span
class="math inline">\(GYM\)</span> <span
class="math inline">\(104065\)</span> <span
class="math inline">\(B\)</span>)</p>
<blockquote>
<p>值域分块，每单点加<span
class="math inline">\(\sqrt{n}\)</span>，将距离<span
class="math inline">\(a[i].k&lt;
\sqrt{n}\)</span>的区间加入线段树，在下一个<span
class="math inline">\(\sqrt{n}\)</span>之前单点修改，直到为<span
class="math inline">\(0\)</span></p>
</blockquote></li>
<li><p><font color='red'><strong>给定<span
class="math inline">\(01\)</span>序列，区间求连续的<span
class="math inline">\(1\)</span>段 （<span
class="math inline">\(LXL讲课\)</span>)</strong></font></p>
<blockquote>
<ol type="1">
<li><p>统计有多少<span class="math inline">\(01\)</span></p></li>
<li><p>统计有多少<span class="math inline">\(11\)</span>，然后所有<span
class="math inline">\(1\)</span>的个数减去连续<span
class="math inline">\(11\)</span>的个数</p></li>
</ol>
</blockquote></li>
<li><p>求第 k 大的距离 (<span
class="math inline">\(JOISC道路の建設案\)</span>)</p>
<blockquote>
<p>二分答案，然后计算距离 <span class="math inline">\(≤dis\)</span>
的点对数</p>
</blockquote></li>
<li><p>区间加，区间开根号 （<span
class="math inline">\(UOJ228\)</span>)</p>
<blockquote>
<p>记录区间内<span
class="math inline">\(max,min\)</span>，开根号时，判断<span
class="math inline">\(min-\sqrt min\)</span>是否等于<span
class="math inline">\(max-\sqrt
max\)</span>，如果等于，等价于区间加一个负数值，如果不等直接继续递归</p>
<p>原因在于开根会导致极差除以<span class="math inline">\(\sqrt max+\sqrt
min\)</span>，这样每个区间最多会进行<span
class="math inline">\(log\)</span>次修改，一次区间加，会导致<span
class="math inline">\(logn\)</span>个区间加1e5，所以总复杂度<span
class="math inline">\(O(nlog^2n)\)</span></p>
</blockquote></li>
<li><p>集合内点两两之间最大距离，可以考虑按照<span
class="math inline">\(2\)</span>进制位数<span
class="math inline">\(0,1\)</span>分<span
class="math inline">\(log\)</span>次，每次求两个集合之间的最大值 ( <span
class="math inline">\(GX/GZOI2019旅行者 P5304\)</span>)</p></li>
<li><p>给定序列，支持序列中元素插入到最后或最前。(<span
class="math inline">\(CF1288E\)</span>)</p>
<blockquote>
<p>在最前或最后直接新建若干空位置即可</p>
</blockquote></li>
<li><p>维护一个数前面有多少个数。(<span
class="math inline">\(CF1288E\)</span>)</p>
<blockquote>
<p>将有数的位置赋值为<span
class="math inline">\(1\)</span>求前缀和即可</p>
</blockquote></li>
<li><p>状压<span
class="math inline">\(DP\)</span>可以考虑记忆化降低复杂度</p></li>
<li><p>本质不同？可以将相同的值加以区分（<span
class="math inline">\(P7448\)</span>)</p></li>
<li><p><font color='red'><strong>连通块个数=黑点个数减去相邻黑点个数</strong>
(<span class="math inline">\(agc003F\)</span>)</font></p></li>
<li><p><font color='red'><strong>多边形内，端点在边界，和切割相关</strong></font></p>
<blockquote>
<p><font color='red'><strong>想到门槛模型，断环成连，变成区间之间的问题。</strong></font></p>
</blockquote></li>
<li><p><span class="math inline">\(sumxor[l,r]=sumxor[1,r]\quad xor
\quad sumxor[1,l-1]\)</span>。</p></li>
<li><p>求最大<span
class="math inline">\(k\)</span>个有序对，等价于求<span
class="math inline">\(2\times k\)</span>个无序对。</p></li>
<li><p><span
class="math inline">\(n\)</span>个集合，每个集合若干个数，取总集合前<span
class="math inline">\(k\)</span>大，<span
class="math inline">\(n\)</span>很大</p>
<blockquote>
<p>异或粽子经典做法，每次都选每个集合的最大值，把选了最大值得集合求次大值.....以此类推</p>
</blockquote></li>
<li><p>对若干次操作后的集合内元素求和：<span
class="math inline">\(f_i\)</span>表示操作后<span
class="math inline">\(\ge i\)</span>的数的数量和，那么答案就是<span
class="math inline">\(\sum_{i=1}^{m} f_i\)</span></p></li>
<li><p>对所有情况求出总和或者每种情况，想差分（<span
class="math inline">\(CF1517F\)</span> <span
class="math inline">\(ARC139D\)</span>)</p></li>
<li><p>子序列问题可以通过证明不交转化成区间问题 (<span
class="math inline">\(CF1610G\)</span>)</p></li>
<li><p>淘汰赛<span class="math inline">\(n\)</span>个人，每次<span
class="math inline">\(k\)</span>个人比赛，那么树高最高是<span
class="math inline">\(\frac{n}{k}\)</span>。</p></li>
<li><p>给你两个可重集 <span class="math inline">\(A,B\)</span>，<span
class="math inline">\(A,B\)</span> 的元素个数都为 <span
class="math inline">\(n\)</span>，它们中每个元素的大小 <span
class="math inline">\(x∈[1,n]\)</span>。请你分别找出 <span
class="math inline">\(A,B\)</span>
的子集，使得它们中的元素之和相等，试证明对于任意序列都存在解。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pp1BQmR"><img
src="https://s1.ax1x.com/2023/03/15/pp1BQmR.png"
alt="pp1BQmR.png" /></a></p>
</blockquote></li>
</ol>
<h1 id="组合数">组合数</h1>
<ol type="1">
<li><p><span
class="math inline">\(C_{l}^2+C_{l}^4+C_{l}^6+C_{l}^8......=2^{l-1}\)</span></p></li>
<li><p>逆元预处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fact[<span class="number">0</span>]=infact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   fact[i]=(ll)i*fact[i<span class="number">-1</span>]%mod;</span><br><span class="line">infact[n]=<span class="built_in">quick_mi</span>(fact[n],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">   infact[i]=(ll)infact[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="关于2">关于2</h1>
<h3 id="位运算">位运算</h3>
<p>​ 1. <span class="math inline">\(i和i+1\)</span>只会存在倒数<span
class="math inline">\(1\rightarrow lowbit(i+1)\)</span>这几位不同 (<span
class="math inline">\(CF1716E\)</span>)</p>
<h3 id="二叉树">二叉树</h3>
<ol type="1">
<li>二叉树，线段树，每一层序号连续，层与层序号连续 (<span
class="math inline">\(CF1716E\)</span>)</li>
</ol>
<h3 id="线性基">线性基</h3>
<ol type="1">
<li><p>原序列中任意一个数都可以由线性基中的若干个数异或出来</p></li>
<li><p>线行基中的数的个数唯一确定，且数的个数最少</p>
<blockquote>
<p>考虑先插入<span class="math inline">\(d1,d2,d3\)</span>后<span
class="math inline">\(x\)</span>无法插入，那么插入<span
class="math inline">\(d1,d2,x\)</span>后<span
class="math inline">\(d3\)</span>无法插入</p>
</blockquote></li>
<li><p>线性基求最大值，从高到低位贪心</p></li>
<li><p>线性基合并，假如有<span class="math inline">\(S1\)</span>和<span
class="math inline">\(S2\)</span>合并，那么先完全插入<span
class="math inline">\(S1\)</span>,再按照普通插入方式依次插入<span
class="math inline">\(S2\)</span>即可</p></li>
</ol>
<h1 id="数据结构">数据结构</h1>
<h3 id="树链剖分">树链剖分</h3>
<ol type="1">
<li><p>问一条路径上相同颜色的颜色段数量，边两端颜色相同的边的数量，最好有序(<span
class="math inline">\(P7735,P2486\)</span>)</p>
<blockquote>
<p>维护一个结构体，存左端点颜色，右端点颜色，中间的答案】</p>
<p>具体写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">range_query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> flg=<span class="number">0</span>;<span class="comment">//flg表示当前答案应归到哪边，0为ans1,1为ans2 </span></span><br><span class="line">	Node h,ans1=(Node)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"> Node ans2=(Node)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">while</span>(topf[x]!=topf[y])&#123;</span><br><span class="line">		<span class="type">int</span> tx=topf[x],ty=topf[y];</span><br><span class="line">		<span class="keyword">if</span>(deep[topf[x]]&lt;deep[topf[y]])&#123; </span><br><span class="line">         flg=!flg;</span><br><span class="line">         <span class="built_in">swp</span>(topf[x],topf[y]);</span><br><span class="line">         <span class="built_in">swp</span>(x,y);</span><br><span class="line">    	&#125;</span><br><span class="line">		<span class="comment">//记得同时取反flg </span></span><br><span class="line">		h=sgtree.<span class="built_in">query</span>(idx[topf[x]],idx[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//一定注意：每次的查询h，一定是左端点在深度小的地方，</span></span><br><span class="line">		<span class="comment">//右端点在深度大的地方，所以千万不能把左右端点合并错 </span></span><br><span class="line">		<span class="keyword">if</span>(flg)</span><br><span class="line">		    ans2=(Node)&#123;</span><br><span class="line">				h.lc,ans2.rc,ans2.cnt+h.cnt+(ans2.lc==h.rc)</span><br><span class="line">			&#125;;</span><br><span class="line">		<span class="comment">//ans2情况 </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans1=(Node)&#123;</span><br><span class="line">				ans1.lc,h.lc,ans1.cnt+h.cnt+(ans1.rc==h.rc)</span><br><span class="line">			&#125;;</span><br><span class="line">		<span class="comment">//ans1情况 </span></span><br><span class="line">		x=fa[topf[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(deep[x]&lt;deep[y])&#123;<span class="built_in">swp</span>(x,y);flg=!flg;&#125;</span><br><span class="line">	h=sgtree.<span class="built_in">query</span>(idx[y],idx[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(flg)</span><br><span class="line">	    ans2=(Node)&#123;</span><br><span class="line">			h.lc,ans2.rc,ans2.cnt+h.cnt+(ans2.lc==h.rc)</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ans1=(Node)&#123;</span><br><span class="line">			ans1.lc,h.lc,ans1.cnt+h.cnt+(ans1.rc==h.rc)</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="comment">//末处理 </span></span><br><span class="line">	<span class="keyword">return</span> ans1.cnt+ans2.cnt+(ans1.rc==ans2.lc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>当遇到边权转点权的时候，不能更新到<span
class="math inline">\(LCA(X,Y)\)</span>，具体处理方法如下</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> tx=top[x],ty=top[y];</span><br><span class="line"> <span class="keyword">while</span>(tx!=ty)&#123;</span><br><span class="line">     <span class="keyword">if</span>(dep[tx]&lt;dep[ty]) <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(tx,ty);</span><br><span class="line">     <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[tx],id[x],k);</span><br><span class="line">     x=fa[tx],tx=top[x];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(x!=y) &#123;</span><br><span class="line">     <span class="keyword">if</span>(id[x]&gt;id[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">     <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x]+<span class="number">1</span>,id[y],k);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>遇到额外边问题，多想想对于连成环的树边的影响(<span
class="math inline">\(P4374\)</span>)</p></li>
<li></li>
</ol>
<h3 id="莫队">莫队</h3>
<figure>
<img src="E:\3_disk_c\pics\屏幕截图%202023-02-14%20092026.png"
alt="屏幕截图 2023-02-14 092026" />
<figcaption aria-hidden="true">屏幕截图 2023-02-14 092026</figcaption>
</figure>
<h3 id="分块">分块</h3>
<ol type="1">
<li>遇到要区间集体右移左移，可以考虑分块，每一个块维护一个<span
class="math inline">\(stl\)</span>,例如<span
class="math inline">\(deque\)</span> （<span
class="math inline">\(CF455D\)</span>)</li>
<li></li>
</ol>
<h1 id="网络流">网络流</h1>
<h3 id="建图技巧">建图技巧</h3>
<ol type="1">
<li></li>
</ol>
<h1 id="stl">STL</h1>
<h3 id="要注意的">要注意的</h3>
<ol type="1">
<li><p><span
class="math inline">\(deque\)</span>是支持中间插入的，(<span
class="math inline">\(insert\)</span>函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator it=deq.<span class="built_in">insert</span>(deq.<span class="built_in">begin</span>()+len,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><span class="math inline">\(prev\)</span>函数，<span
class="math inline">\(prev(iterator,dis)\)</span>返回距离<span
class="math inline">\(iterator\)</span>左侧<span
class="math inline">\(dis\)</span>个距离的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt;::iterator it = mylist.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧</span></span><br><span class="line"><span class="keyword">auto</span> newit = <span class="built_in">prev</span>(it, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;prev(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//n为负数，newit 位于 it 右侧</span></span><br><span class="line">it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">newit = <span class="built_in">prev</span>(it, <span class="number">-2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;prev(it, -2) = &quot;</span> &lt;&lt; *newit;</span><br></pre></td></tr></table></figure></li>
<li><p>离散化板子要记牢</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(lsh+<span class="number">1</span>,lsh+n+<span class="number">1</span>);</span><br><span class="line">cnt=<span class="built_in">unique</span>(lsh+<span class="number">1</span>,lsh+n+<span class="number">1</span>)-lsh<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//unique指向的是第一个重复的元素，所以剔除重复元素需要-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	num[i]=<span class="built_in">lower_bound</span>(lsh+<span class="number">1</span>,lsh+cnt+<span class="number">1</span>,num[i])-lsh;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li></li>
</ol>
<h3 id="更高级的应用">更高级的应用</h3>
<h1 id="二维数点">二维数点</h1>
<p>注意，这里的<span
class="math inline">\(x,y\)</span>都是二维平面，不是二维数组，特殊情况会附加说明。</p>
<ol type="1">
<li><p>多次询问，每次询问<span
class="math inline">\(y\in[1,z],x\in[l,r]，min(f[x][y])\)</span>。</p>
<blockquote>
<p>对<span
class="math inline">\(x\)</span>做扫描线，从1开始扫描，往上扫描，每次将<span
class="math inline">\(x=i\)</span>与线段树原有点取min，然后当<span
class="math inline">\(i=z\)</span>的时候，线段树询问<span
class="math inline">\(l\rightarrow r\)</span>区间的<span
class="math inline">\(min\)</span>即可</p>
</blockquote>
<p><img src="E:\3_disk_c\pics\1_1.png" alt="1_1" style="zoom: 67%;" /></p></li>
<li><p>多次询问，每次询问一个矩形内最小的数。</p>
<blockquote>
<p>二位线段树（第二维动态开点）</p>
</blockquote></li>
<li><p>有<span class="math inline">\(2n\)</span>个点对<span
class="math inline">\((x_i,y_i)\)</span>，每个点有权值<span
class="math inline">\(v_i\)</span>，每次给定区间<span
class="math inline">\(l,r\)</span>，求<span
class="math inline">\(min_{l\le xi,yi \le r} v_i\)</span> （<span
class="math inline">\(CF1635C\)</span>)</p>
<blockquote>
<p>也是普通二位数点，做法：将询问挂在右端点，扫描线，到达右端点后直接区间查询线段树，单点更新以当前点为右端点的点对。</p>
</blockquote></li>
<li><p>两棵树，每个点在两棵树上的位置不同，问既在第一棵树的<span
class="math inline">\(a\)</span>子树内，又在第二棵树的<span
class="math inline">\(b\)</span>子树内的点的个数 (<span
class="math inline">\(模拟赛20\)</span>)</p>
<blockquote>
<p>转化成每个点有两个属性<span
class="math inline">\(a,b\)</span>，分别表示在第一个树和第二个树上的<span
class="math inline">\(dfn\)</span>序，就变成标准长方形数点问题了</p>
<p>其实也可以不使用二维数点，将在第一棵树的<span
class="math inline">\(u\)</span>子树的答案差分一下，变成答案减去在扫描到<span
class="math inline">\(in[u]-1\)</span>的时候已经存在于第二棵树的<span
class="math inline">\(v\)</span>子树的点，再加上扫描到<span
class="math inline">\(ed[u]\)</span>的时候存在于子树<span
class="math inline">\(v\)</span>内的点即可。</p>
</blockquote>
<p><img src="E:\3_disk_c\pics\1_2.png" alt="1_2" style="zoom:80%;" /></p></li>
</ol>
<h1 id="复杂度">复杂度</h1>
<ol type="1">
<li><p>树上启发式合并（堆）是，<span
class="math inline">\(O(nlogn^2)\)</span></p></li>
<li><p><span
class="math inline">\(\frac{x}{1}+\frac{x}{2}+\frac{x}{3}+.....+\frac{x}{x}=O(xlogx)\)</span></p></li>
<li><p><span class="math inline">\(\sqrt n+\sqrt \frac{n}{2}+\sqrt
\frac{n}{4}+\sqrt \frac{n}{8}+....=\sqrt n\)</span></p></li>
</ol>
<h1 id="题意转化">题意转化</h1>
<ol type="1">
<li>求所有方案的操作数之和，可以考虑对称性（<span
class="math inline">\(CF1193A\)</span>)</li>
<li>序列上<span class="math inline">\(i\rightarrow
a[i]\)</span>立马想到基环树</li>
</ol>
<h1 id="网格图问题">网格图问题</h1>
<ol type="1">
<li><p>给定若干个矩形，然后求每个点被覆盖到的矩形集合中，左边界最靠左的那一个是谁（下同理）</p>
<blockquote>
<p>考虑在加入一个矩形的时候，对于这个矩形的右边界，将所有右边界的<span
class="math inline">\(L\)</span>值更新为左边界的横坐标值，最后从右往左扫描一遍，每次<span
class="math inline">\(dp[i][j]=min(dp[i][j],dp[i+1][j])\)</span>即可，当然初始化的时候肯定是自己</p>
</blockquote></li>
<li><p>网格多米诺问题：状压倒数一行或者倒数一二行。</p></li>
</ol>
<h1 id="杂项-1">杂项</h1>
<h3 id="平方数相关">平方数相关</h3>
<ol type="1">
<li>相同的数相乘是平方数，考虑把两个数分别分解成平方数乘常数(<span
class="math inline">\(CF840C\)</span>)</li>
<li><span class="math inline">\(\prod ^{2k}_{i=1}i!=\prod
^{k}_{i=1}\left( 2i\right) !\times \left( 2i-1\right)!=\left( \prod
^{k}_{i=1}\left( 2i-1\right) !\right) ^{2}\times 2^{k}\times
k!\)</span></li>
<li>快速判断是否是平方数：给每一个质因子赋一个随机值，如果一个数的所有质因子的<span
class="math inline">\(hash\)</span>结果是<span
class="math inline">\(0\)</span>则是平方数</li>
<li><span class="math inline">\(a\times b\)</span>如果炸了，考虑<span
class="math inline">\(log(a\times b)=log(a)+log(b)\)</span></li>
</ol>
<h3 id="约数相关">约数相关</h3>
<ol type="1">
<li>涉及到枚举<span class="math inline">\(x\in [1,n],y\in[1,n],x\times
y=z\)</span>，可以考虑转向枚举<span
class="math inline">\(z\)</span>的因数，降低复杂度(<span
class="math inline">\(CF1677E\)</span>)</li>
<li></li>
</ol>
<h1 id="一些杂题">一些杂题</h1>
<ul>
<li>CF1574E</li>
<li>CF1633F</li>
<li>CF1651E</li>
<li>CF1644F</li>
<li>CF1697E</li>
<li>CF1519E</li>
<li>CF1519F</li>
<li>CF1469E</li>
<li>CF1455E</li>
<li>P7561</li>
<li>CF1278E</li>
<li>CF1487F</li>
</ul>
<h1 id="特殊题型">特殊题型</h1>
<h3 id="times-n格子问题"><span class="math inline">\(2\times
n\)</span>格子问题</h3>
<ul>
<li>CF1739E</li>
</ul>
<h3 id="全局计算问题-lin1nrin1n">全局计算问题 (<span
class="math inline">\(l\in[1,n]，r\in[1,n]\)</span>)</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/23/DS%E9%A2%98%E7%9B%AE%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="starslight">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/23/DS%E9%A2%98%E7%9B%AE%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" class="post-title-link" itemprop="url">DS题目（基础）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-03-23 00:00:00 / Modified: 22:42:57" itemprop="dateCreated datePublished" datetime="2023-03-23T00:00:00+08:00">2023-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ahoi2013-作业">[AHOI2013] 作业</h1>
<blockquote>
<p>区间求值域在<span
class="math inline">\([a,b]\)</span>的数的个数和种类</p>
</blockquote>
<p>由于有<span class="math inline">\(O(n\sqrt
m)\)</span>复杂度的修改和<span
class="math inline">\(O(m)\)</span>的查询，我们需要<span
class="math inline">\(O(1)\)</span>修改，<span
class="math inline">\(O(\sqrt n)\)</span>查询的东西，自然是</p>
<p>分块。</p>
<p>于是考虑值域分块即可。</p>
<h1 id="p3709-大爷的字符串题">[P3709] 大爷的字符串题</h1>
<blockquote>
<p>询问一个区间能被拆成至少几个(严格的)<span
class="math inline">\(LIS\)</span> （求区间众数的出现次数）</p>
</blockquote>
<p>等价于：给你 <span class="math inline">\(n\)</span> 个数, <span
class="math inline">\(m\)</span> 次询问区间 <span
class="math inline">\([l,r]\)</span> 中众数的出现次数。</p>
<p>然后就是区间众数的处理方法。</p>
<p><span class="math inline">\(cnt[i]\)</span> 表示数 <span
class="math inline">\(i\)</span> 出现的次数, <span
class="math inline">\(t[i]\)</span> 表示出现 <span
class="math inline">\(i\)</span> 次的数有多少个。</p>
<p>加入一个数时,把 <span class="math inline">\(Ans\)</span> 和 <span
class="math inline">\(cnt\)</span> 取个<span
class="math inline">\(Max\)</span>。</p>
<p>删除一个数时,如果有<span class="math inline">\(t[cnt]==1\)</span>
&amp;&amp; <span class="math inline">\(cnt==Ans\)</span>，那么就 <span
class="math inline">\(Ans−−\)</span></p>
<h1 id="小清新人渣本愿">小清新人渣本愿</h1>
<blockquote>
<p>区间求是否有：和，差，积为<span
class="math inline">\(x\)</span>的一对数</p>
</blockquote>
<p><span class="math inline">\(bitset\)</span>，判断<span
class="math inline">\(S\)</span> &amp; <span
class="math inline">\((S&gt;&gt;x)\)</span>，和的话可以维护一个倒着的<span
class="math inline">\(bitset\)</span>。</p>
<h1 id="模拟赛-29-b">模拟赛 29 B</h1>
<blockquote>
<p>给定一棵树和序列，区间跳<span
class="math inline">\(father\)</span>，区间求<span
class="math inline">\(min_{l≤i≤r}\)</span> <span
class="math inline">\(dep(a_i)\)</span></p>
</blockquote>
<p>分块，让每个块至多总共跳<span
class="math inline">\(n\)</span>次以来均摊复杂度，所以如果一个块内的点同时跳的时候遇到了之前</p>
<p>跳到过的点就别跳了。</p>
<p>时间复杂度分析：对于一次散块修改，首先<span
class="math inline">\(\sqrt n\times log(n)\)</span>还原块，再<span
class="math inline">\(\sqrt n\)</span>暴力跳父亲，然后<span
class="math inline">\(\sqrt n\)</span>修</p>
<p>改<span
class="math inline">\(vector\)</span>，对于整块修改，其总共不会超过<span
class="math inline">\(O(n)\)</span>，总共有<span
class="math inline">\(\sqrt n\)</span>个块，所以总共是<span
class="math inline">\(O(n\times \sqrt n)\)</span>的。</p>
<p>总共修改的散块个数是<span class="math inline">\(2\times
n\)</span>的，也就是说就算<span
class="math inline">\(vector\)</span>要重构也总共只用重构<span
class="math inline">\(2\times n\times \sqrt n\)</span>的。</p>
<h1 id="heoi2015-公约数数列">[HEOI2015] 公约数数列</h1>
<blockquote>
<ol type="1">
<li>将 <span class="math inline">\(a_i\)</span> 修改为 <span
class="math inline">\(x\)</span>.</li>
<li>求最小的整数 <span class="math inline">\(p(0≤p&lt;n)\)</span>，使得
<span class="math inline">\(gcd(a0,a1,...,ap)\times
XOR(a0,a1,...,ap)=x\)</span></li>
</ol>
</blockquote>
<p>首先注意到前缀 <span class="math inline">\(gcd\)</span> 种类不超过
<span class="math inline">\(log\)</span>
个，所以产生变化的位置甚至可以枚举。</p>
<p>然后我们从前往后枚举，对于 <span class="math inline">\(gcd\)</span>
不变的整块，只需要用 <span class="math inline">\(map\)</span>
找到有无异或前缀和等于 <span class="math inline">\(x/gcd\)</span>。</p>
<p>单点修改？只用<strong>修改当前块的 <span
class="math inline">\(map\)</span> </strong></p>
<p>原因在于，修改是<span
class="math inline">\(10000\)</span>的，查询是<span
class="math inline">\(10000\)</span>的，我们希望做到查询修改都是 <span
class="math inline">\(\sqrt n\)</span>的，所以我们只能</p>
<p>修改一个块的<span
class="math inline">\(map\)</span>，查询的时候每经过一个块就再 <span
class="math inline">\(xor\)</span> 一次总块。</p>
<p>如果一个块内出现了不同的 <span class="math inline">\(gcd\)</span>
就暴力扫块，然后至多有 <span class="math inline">\(log\)</span>
个块要暴力扫。</p>
<h1 id="p3603-雪辉">P3603 雪辉</h1>
<blockquote>
<p>给定一棵树，求链的并的点权种类以及<span
class="math inline">\(mex\)</span></p>
</blockquote>
<p><del>太强了太强了</del></p>
<p>看到 <span class="math inline">\(mex\)</span> 和数颜色可以想到 <span
class="math inline">\(bitset\)</span>，然后直觉上是每个链维护一个<span
class="math inline">\(bitset\)</span>然后合并。</p>
<p>也就是一颗线段树，所有的 <span class="math inline">\(nlogn\)</span>
个节点中，每个点有一个 <span
class="math inline">\(bitset\)</span>，这样做空间开不下。</p>
<p>然后发现这很类似于线段树合并，底部的两层几乎只有<span
class="math inline">\(1,2\)</span>个数，于是下两层用<span
class="math inline">\(pair\)</span>存。</p>
<ul>
<li><p>线段树的节点分布：<span
class="math inline">\(2^0+2^1+...2^k\)</span>满足<span
class="math inline">\(2^k\ge n\)</span>，那么去掉最后一行就最多只有<span
class="math inline">\(n\)</span>个节点</p>
<p>也就是：线段树的节点个数 <span class="math inline">\(-\)</span>
最后一行的节点个数 <span class="math inline">\(\approx\)</span>
n</p></li>
</ul>
<h1 id="at_joisc2014_c歴史の研究">[AT_joisc2014_c]歴史の研究</h1>
<blockquote>
<p>询问区间最大的<span class="math inline">\(val\times time\)</span>
（值乘上出现次数）</p>
</blockquote>
<p>首选想到莫队，然后伸展很好做，缩小很难做，那么采用回滚莫队</p>
<p>注意，在操作的时候，要先把单独右边的贡献给记录到 <span
class="math inline">\(lst\)</span>
里面，然后再移动左端点，这样在左端</p>
<p>点移动回来的时候才能正确初始答案。</p>
<p>这个时候的排序要格外注意了，就必须严格用 <span
class="math inline">\(belong\)</span> 了。</p>
<h1 id="zjoi2013k大数查询">[ZJOI2013]K大数查询</h1>
<blockquote>
<ul>
<li><code>1 l r c</code>：表示将 <span class="math inline">\(c\)</span>
加入到编号在 <span class="math inline">\([l,r]\)</span> 内的集合中</li>
<li><code>2 l r c</code>：表示查询编号在 <span
class="math inline">\([l,r]\)</span> 内的集合的并集中，第 <span
class="math inline">\(c\)</span> 大的数是多少。</li>
</ul>
</blockquote>
<p>采用树套树，先在外层套一个权值线段树，每一个点存当前权值在哪些集合里面出现过，这个用动态开点线段树然</p>
<p>后查询的时候就在最外层的权值线段树上二分就可以了。</p>
<h1 id="cf620e">CF620E</h1>
<blockquote>
<p>其实原题挺简单的，拿<span
class="math inline">\(bitset\)</span>就能做了，但是如果<span
class="math inline">\(a[i]\)</span>达到了 <span
class="math inline">\(100\)</span> 怎么做呢？</p>
</blockquote>
<p>我们可以考虑把<span class="math inline">\(100\)</span> 拆分成前<span
class="math inline">\(50\)</span>和后<span
class="math inline">\(50\)</span>，就能做了。</p>
<h1 id="p4145-上帝造题的7分钟-2">P4145 上帝造题的7分钟 2</h1>
<blockquote>
<p>区间开根，区间询问和</p>
</blockquote>
<p>做法简单，一个数开根<span
class="math inline">\(log\)</span>次就会变成<span
class="math inline">\(1\)</span>，然后就不会变了，于是考虑维护区间最大值，如果最大值不超过<span
class="math inline">\(1\)</span>就不要</p>
<p>递归下去了。</p>
<p>这道题的关键在于时间复杂度的分析，我们直接分析每一次操作的复杂度是很难的，于是我们换一个角度考虑，我</p>
<p>们发现所有<span
class="math inline">\(n\)</span>个数，每个数都至多会被操作<span
class="math inline">\(6\)</span>次，我们假设每一次操作都是单点修改，会带上<span
class="math inline">\(log\)</span> ，于是严谨一些的</p>
<p>总复杂度为<span class="math inline">\(O(6\times n\times
logn)\)</span>了。</p>
<ul>
<li><p>区间的有些操作虽然难以维护，但是可以通过操作的性质对于区间进行合并处理。</p>
<p>完全合并需要的次数（即总势能）只要在可接受范围内，那么这个<strong>暴力修改+剪枝</strong>的做法就是可以接受的。</p></li>
</ul>
<h1 id="uoj228-基础数据结构练习题">UOJ228 基础数据结构练习题</h1>
<blockquote>
<p>区间加，区间开根，区间求和</p>
</blockquote>
<p>记录区间内<span
class="math inline">\(max,min\)</span>，开根号时，判断<span
class="math inline">\(min-\sqrt min\)</span>是否等于<span
class="math inline">\(max-\sqrt
max\)</span>，如果等于，等价于区间加一个</p>
<p>负数值，如果不等直接继续递归。</p>
<p>原因在于开根会导致<span class="math inline">\(max-min \rightarrow
\sqrt max-\sqrt min\)</span> ，其实也就是极差除以<span
class="math inline">\(\sqrt max+\sqrt min\)</span>，</p>
<p>至于时间复杂度，我们这样考虑它，如果有一个区间里的数全部都相等，那么我们其实是可以<span
class="math inline">\(O(1)\)</span>的打上加减标</p>
<p>记的，如果没有加法，那么最多进行 <span
class="math inline">\(6nlogn\)</span> 次操作序列就会全部变成<span
class="math inline">\(1\)</span>，但很不幸的是我们有区间加法操作，但</p>
<p>是每次区间加法操作只会使得<span
class="math inline">\(2logn\)</span>个区间的<span
class="math inline">\(min-\sqrt min\)</span>和<span
class="math inline">\(max-\sqrt
max\)</span>产生改变，我们又需要对于每一个</p>
<p>这样的区间执行<span
class="math inline">\(6\)</span>次的修改，所以每次区间加法造成的影响是
<span class="math inline">\(2\times 6 \times
logn\)</span>的，所以是<span
class="math inline">\(log^2n\)</span>的，加法操作是</p>
<p><span class="math inline">\(nlogn\)</span>的，所以大致复杂度是<span
class="math inline">\(nlog^2n\)</span>的。</p>
<h1 id="cf438d-the-child-and-sequence">CF438D The Child and
Sequence</h1>
<blockquote>
<p>区间取模，区间求和，单点修改</p>
</blockquote>
<p>这道题其实也隐藏了 <span class="math inline">\(log\)</span>
的性质，具体的：$ x  mod  p &lt; $。</p>
<p>所以我们可以照葫芦画瓢，记录区间最大值，再加上单点修改，然后同花神游历各国就行了，唯一的区别在于复杂</p>
<p>度，花游是<span class="math inline">\(6nlogn\)</span>，这一个是<span
class="math inline">\(nlog^2n\)</span>的，对于单点加操作的理解同上一题。</p>
<h1 id="cf431e-chemistry-experiment">CF431E Chemistry Experiment</h1>
<blockquote>
<ul>
<li><span class="math inline">\(1\)</span> <span
class="math inline">\(p\)</span> <span
class="math inline">\(x\)</span>：倒掉试管<span
class="math inline">\(p\)</span>的水银修改为<span
class="math inline">\(x\)</span> <span
class="math inline">\(ml\)</span>。</li>
<li><span class="math inline">\(2\)</span> <span
class="math inline">\(v\)</span>：将<span
class="math inline">\(v\)</span> <span
class="math inline">\(ml\)</span>水任意分配至<span
class="math inline">\(n\)</span>支试管里，最小化有<strong>水</strong>的试管中最大体积，输出这个最小值，误差不超过<span
class="math inline">\(10^{-4}\)</span>算作正确。。这个操作只是一次假想，不会真的把水倒进试管里。</li>
</ul>
</blockquote>
<p>直接二分答案 <span
class="math inline">\(mid\)</span>，判断可不可行就线段树查询值域小于<span
class="math inline">\(mid\)</span>的值的和，然后用</p>
<p><span class="math inline">\(mid\times num\)</span>减去，再看是否大于
<span class="math inline">\(v\)</span>
就可以了，要注意的是这题需要动态开点的线段树。</p>
<h1 id="p2184-贪婪大陆">P2184 贪婪大陆</h1>
<blockquote>
<p>每次操作会加入新的线段，问有多少条线段与区间相交</p>
</blockquote>
<p>注意是不能直接取 <span class="math inline">\(max\)</span>
的，因为会遇到这种情况：</p>
<p><img src="E:\3_disk_c\DS\pics\1.png" alt="1" style="zoom:80%;" /></p>
<p>这个时候，我们其实可以维护两个东西：</p>
<ul>
<li>维护节点<span
class="math inline">\(i\)</span>，之前有几个线段的开头，设为<span
class="math inline">\(st(i)\)</span>。</li>
<li>维护节点<span
class="math inline">\(i\)</span>，之前有几个线段的结尾，设为<span
class="math inline">\(ed(i)\)</span>。</li>
</ul>
<p>那么实际询问要求的就是 <span
class="math inline">\(st[r]-ed[l-1]\)</span>。</p>
<h1 id="p1438-无聊的数列">P1438 无聊的数列</h1>
<blockquote>
<p>区间加等差数列，单点查询</p>
</blockquote>
<p>我们发现等差数列这个东西是可合并的，也就是：</p>
<p>一个首项为<span class="math inline">\(A\)</span>，公差为<span
class="math inline">\(B\)</span>的数列，加上一个首项为<span
class="math inline">\(C\)</span>，为<span
class="math inline">\(D\)</span>的数列可以合成一个首项为</p>
<p><span class="math inline">\(A+C\)</span>，公差为<span
class="math inline">\(B+D\)</span>的序列。于是我们在线段树上记录首项和公差即可。</p>
<p><strong style="color:red;">----------------------------------------------一次复习分割线--------------------------------------------------</strong></p>
<h1 id="cf992e-nastya-and-king-shamans">CF992E Nastya and
King-Shamans</h1>
<blockquote>
<p>给定一个序列 <span class="math inline">\(a_i\)</span>
，记其前缀和序列为 <span class="math inline">\(s_i\)</span> ，有 <span
class="math inline">\(q\)</span> 个询问，每次单点修改，询问是否存在一个
<span class="math inline">\(i\)</span> 满足 <span
class="math inline">\(a_i=s_{i-1}\)</span>
，有多解输出任意一个，无解输出 <span class="math inline">\(−1\)</span>
。</p>
</blockquote>
<p>说白了还是在找<span
class="math inline">\(log\)</span>，我们发现如果有一个位置满足 <span
class="math inline">\(a_i-s_{i-1} \ge 0\)</span>，这样的位置不超过</p>
<p><span class="math inline">\(log\)</span>
个，证明显然，所以直接大力维护 <span
class="math inline">\(a_i-s_{i-1}\)</span> 然后判断区间 <span
class="math inline">\(max\)</span> 是否大于<span
class="math inline">\(0\)</span>即可。再</p>
<p>来考虑怎么修改，我们可以考虑修改 <span
class="math inline">\(delta\)</span> 而不是原值，所以在位置 <span
class="math inline">\(x\)</span> 单点 <span
class="math inline">\(+delta\)</span>, <span
class="math inline">\(x\)</span> 以</p>
<p>后的所有位置 <span class="math inline">\(-delta\)</span> 即可。</p>
<h1 id="cf1000f-one-occurence">CF1000F One Occurence</h1>
<blockquote>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 序列，<span
class="math inline">\(m\)</span> 个询问，每次询问给定一个区间 <span
class="math inline">\([l,r]\)</span>，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出
<span class="math inline">\(0\)</span></p>
</blockquote>
<p>直接莫队+分块莽！可以考虑值域分块，这样每一次的修改就变成 <span
class="math inline">\(O(1)\)</span>的了，查询的时候</p>
<p>照常做就行。</p>
<h1 id="cf1149c-tree-generator">CF1149C Tree Generator™</h1>
<blockquote>
<p>给你一棵树的括号序列，输出它的直径。</p>
<p>有<span
class="math inline">\(m\)</span>次询问，每次询问表示交换两个括号，输出交换两个括号后的直径（保证每次操作后都为一棵树）</p>
</blockquote>
<p>首先要观察出一个性质：<strong>括号序列上任何一个子区间，去掉所有匹配的括号后，得到的</strong></p>
<p><strong>括号序列一定是树上一条链</strong>，而且链的两端就是括号序列的两端！</p>
<p>去掉所有匹配的括号是复杂的，我们可以考虑确定性问题转<span
class="math inline">\(max,min\)</span>，也就是<strong>对于所</strong></p>
<p><strong>有子区间，找到一个分界点，右区间权值和 −
左区间权值和的最大值，为这个子区间</strong></p>
<p><strong>的路径长度最大值</strong>，其中钦定左括号是<span
class="math inline">\(+1\)</span>，右括号是<span
class="math inline">\(-1\)</span>，我们发现最后最优解一定是被</p>
<p>覆盖到的，而且不优解也会被排除掉。</p>
<h1 id="cf1422f-boring-queries">CF1422F Boring Queries</h1>
<blockquote>
<p>区间求<span class="math inline">\(LCM\)</span>，强制在线</p>
</blockquote>
<p><span class="math inline">\(LCM\)</span>和<span
class="math inline">\(GCD\)</span>的关系是很大的，观察到如果一个区间里有大于<span
class="math inline">\(\sqrt n\)</span>的质因子，那么这个数</p>
<p>只要出现过我们就会乘上，相当于变成了存在性问题，那么对于小于<span
class="math inline">\(\sqrt n\)</span>的质因子，这样的</p>
<p>质因子有<span class="math inline">\(87\)</span>个，可以直接拿<span
class="math inline">\(87\)</span>个<span
class="math inline">\(ST\)</span>表维护区间最大值。</p>
<p>对于存在性问题，可以考虑<span
class="math inline">\(HH\)</span>的项链，但是强制在线，这也很好处理，加上可持久化就可</p>
<p>以了，具体的我们维护一个 <span class="math inline">\(root[i]\)</span>
表示扫描线扫到 <span class="math inline">\(i\)</span>
的时候线段树的状况，那么我们在查</p>
<p>询区间<span
class="math inline">\([l,r]\)</span>的时候自然就会想到，找到<span
class="math inline">\(root[r]\)</span>，然后查询这个版本的 <span
class="math inline">\([l,r]\)</span>即可。</p>
<h1 id="cf617e-xor-and-favorite-number">CF617E XOR and Favorite
Number</h1>
<blockquote>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(a\)</span>，然后再给一个数字 <span
class="math inline">\(k\)</span>，再给出 <span
class="math inline">\(m\)</span>
组询问，每组询问给出一个区间，求这个区间里面有多少个子区间的异或值为
<span class="math inline">\(k\)</span>。</p>
</blockquote>
<p>最初的想法是：对于每一个右端点找到对应的位置，然后再考虑二维数点，使用<span
class="math inline">\(KDtree\)</span>解决。但是如果所有数一</p>
<p>样，就会退化成<span class="math inline">\(O(n^2)\)</span>。</p>
<p>考虑莫队，直接维护前缀异或和就好了，有三个细节要注意：</p>
<ul>
<li><p>因为是<span class="math inline">\(s[l-1]\)</span>和<span
class="math inline">\(s[r]\)</span>，所以初始读入的 <span
class="math inline">\(l\)</span> 要减去 <span
class="math inline">\(1\)</span></p></li>
<li><p><span class="math inline">\(pos[0]\)</span>要初始化为 <span
class="math inline">\(1\)</span>。</p></li>
<li><p>因为是异或，数组开大一点，至少到<span
class="math inline">\(1&lt;&lt;20\)</span></p></li>
</ul>
<h1 id="hnoi2016大数">[HNOI2016]大数</h1>
<blockquote>
<p>多次询问，不带修改，询问区间大数能整除<span
class="math inline">\(p\)</span>的个数</p>
</blockquote>
<p>我们发现从后面添数是容易的，从前面添加是困难的。因为从前只需要找到<span
class="math inline">\(A=\frac{P-B}{10^i mod P}\)</span>。</p>
<p><span
class="math inline">\([L,R]×10^{n−R}=sum[L]−sum[R+1]\)</span></p>
<p><span
class="math inline">\(⇒[L,R]=\frac{sum[L]−sum[R+1]}{10^{n−R}}\)</span></p>
<p>∴ <span class="math inline">\(sum[L] mod P=sum[R+1] mod
P\)</span></p>
<p>然后就成了小<span class="math inline">\(Z\)</span>的袜子</p>
<h1 id="cf940f-machine-learning">CF940F Machine Learning</h1>
<blockquote>
<ol type="1">
<li><p>查询区间 <span class="math inline">\([l,r]\)</span>
中每个数字出现次数的 <span class="math inline">\(mex\)</span>。</p></li>
<li><p>单点修改某一个位置的值。</p></li>
</ol>
</blockquote>
<p>考虑带修莫队，首先观察到一点，答案一定是小于<span
class="math inline">\(\sqrt
n\)</span>的，于是先带修莫队，然后暴力扫描</p>
<p><span class="math inline">\(mex\)</span>就可以了。</p>
<p>注意带修改的莫队，要先按照 <span class="math inline">\(l\)</span>
所在块排序，再按 <span class="math inline">\(r\)</span>
所在的块排序，最后按照 <span class="math inline">\(t\)</span>
排序。时间</p>
<p>复杂度证明如下：</p>
<figure>
<img src="E:\3_disk_c\DS\pics\2.png" alt="2" />
<figcaption aria-hidden="true">2</figcaption>
</figure>
<h1 id="cf1787g-colorful-tree-again">CF1787G Colorful Tree Again</h1>
<blockquote>
<p>定义一条路径为好，当且仅当：</p>
<p>1、所有边同色。</p>
<p>2、所有点均没有被锁。</p>
<p>3、包含了这种颜色的所有边。</p>
<p>定义一条路径的权值为边权之和。</p>
<p>现给定一棵树，有多次操作，每次锁或解锁一个点，你需要求出最大的好路径的权值，若不存在输出
<span class="math inline">\(0\)</span>。</p>
</blockquote>
<h1 id="cf1783g-weighed-tree-radius">CF1783G Weighed Tree Radius</h1>
<blockquote>
<p>给定一棵 <span class="math inline">\(n\)</span> 个点，第 <span
class="math inline">\(i\)</span> 个点有点权 <span
class="math inline">\(a_i\)</span> 的树，对于一个点 <span
class="math inline">\(u\)</span> 定义偏心距 <span
class="math inline">\(e(u)=max⁡\)</span> {<span
class="math inline">\({dis(u,v)+a_v}\)</span>}，其中 <span
class="math inline">\(dis(u,v)\)</span>表示两点在树上的距离。定义半径
<span class="math inline">\(r=min⁡\)</span> <span
class="math inline">\(e_u\)</span>。</p>
<p><span class="math inline">\(m\)</span> 次单点修改，每次修改后询问
<span class="math inline">\(r\)</span>。</p>
</blockquote>
<h1 id="cf1774g-segment-covering">CF1774G Segment Covering</h1>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个区间 <span
class="math inline">\([x_i,y_i]\)</span>，保证所有区间均不同。令 <span
class="math inline">\(f(l,r)\)</span> 表示从 <span
class="math inline">\(n\)</span>
个区间中选择偶数个区间使得其求并集后恰为 <span
class="math inline">\([l,r]\)</span> 的方案数，令 <span
class="math inline">\(g(l,r)\)</span> 表示从 <span
class="math inline">\(n\)</span>
个区间中选择奇数个区间使得其求并集后恰为 <span
class="math inline">\([l,r]\)</span> 的方案数。给定 <span
class="math inline">\(q\)</span> 组询问 <span
class="math inline">\([l_i,r_i]\)</span>，输出 <span
class="math inline">\(f(l_i,r_i)−g(l_i,r_i)\)</span></p>
</blockquote>
<p>首先挖掘性质：如果有两条线段 <span
class="math inline">\(X,Y\)</span>，其中 <span
class="math inline">\(X\)</span> 包含了 <span
class="math inline">\(Y\)</span> ，那么 <span
class="math inline">\(X\)</span> 可以被删除，原因在于如果有方案选择了
<span class="math inline">\(X\)</span>, 那么 <span
class="math inline">\(Y\)</span> 的选择会对奇偶同时产生贡献。</p>
<p>然后我们考虑对于一个区间 <span
class="math inline">\([l,r]\)</span>，我们把所有在这个区间内的线段提取出来，按照左端点排序，很容易发现第一条线段是必须选的，但是如果我们选择了三线段，那么二线段的有无又会同时产生贡献，于是三号线段是没有用的。</p>
<p><img src="E:\3_disk_c\DS\pics\3.png" alt="3" style="zoom:80%;" /></p>
<p>那么我们发现四号，五号....都被删除了，最后停在了某一号如图：</p>
<p><img src="E:\3_disk_c\DS\pics\4.png" alt="4" style="zoom:80%;" /></p>
<p>然后二号就变成了必选。</p>
<p>那么按照上面的方法删除线段后，只剩下了 <span
class="math inline">\(k\)</span> 条必须选择的线段，答案就是<span
class="math inline">\((-1)^k\)</span></p>
<p>每次询问我们先找到左端点就是 <span class="math inline">\(l\)</span>
的线段和左端点大于 <span class="math inline">\(l\)</span>
且最小的两条线段作为起始线段。从他们开始，设他们编号 <span
class="math inline">\(1,2\)</span>，我们先从 <span
class="math inline">\(1\)</span> 找到一个左端点大于 <span
class="math inline">\(r\)</span> 且最小的线段 <span
class="math inline">\(3\)</span>，再对 <span
class="math inline">\(2\)</span> 做，一直这么做下去，直到右端点到达
<span class="math inline">\(r\)</span>。</p>
<p>那么我们按照上面这个步骤进行一个预处理：对于线段 <span
class="math inline">\(i\)</span>，我们找到最小的 <span
class="math inline">\(j\)</span> 满足<span
class="math inline">\(l_j&gt;r_i\)</span>，建一棵树（森林），我们令
<span
class="math inline">\(fa[i]=j\)</span>。事实上不用把树显式建出来，只要
<span class="math inline">\(fa\)</span> 数组就行。</p>
<p>这样我们每次先找到两条初始线段，只要线段范围没有超过 <span
class="math inline">\(r\)</span>，就一直倍增向后面跳 <span
class="math inline">\(fa\)</span> ，如果最终两条线段的右端点还没到 <span
class="math inline">\(r\)</span>，或者最终两条线段是相同的，那么答案就是
<span class="math inline">\(0\)</span> 了。</p>
<p><img src="E:\3_disk_c\DS\pics\5.png" alt="5" style="zoom: 80%;" /></p>
<h1 id="cf1004f-sonya-ans-bitwise-or">CF1004F Sonya ans Bitwise OR</h1>
<blockquote>
<ol type="1">
<li>将 <span class="math inline">\(a_i\)</span> 修改成 <span
class="math inline">\(y\)</span> ；</li>
<li>给定 <span class="math inline">\(l\)</span> 和 <span
class="math inline">\(r\)</span> ，询问有多少个区间 <span
class="math inline">\([L,R]\)</span> 满足 <span
class="math inline">\(l≤L≤R≤r\)</span> 且 <span
class="math inline">\(aL∼aR\)</span> 按位或和至少为 <span
class="math inline">\(x\)</span></li>
</ol>
</blockquote>
<p>这个题目给了我们全新的角度去观察 <span
class="math inline">\(or\)</span> ，那就是：</p>
<ul>
<li>前缀 <span class="math inline">\(or\)</span>
是单调不减的，所以可以分治双指针。</li>
<li>不同的前缀 <span class="math inline">\(or\)</span> 种类是不超过
<span class="math inline">\(log\)</span> 个的。</li>
</ul>
<p>所以我们可以考虑对于线段树上每一个节点，记录前缀后缀<span
class="math inline">\(or\)</span>的种类和长度，这样的</p>
<p>位置至多只有 <span class="math inline">\(log\)</span>
个所以合并的时候可以考虑暴力合并。</p>
<h1 id="cf1114f-please-another-queries-on-array">CF1114F Please, another
Queries on Array？</h1>
<blockquote>
<ol type="1">
<li><p><code>MULTIPLY l r x</code>，对于所有 <span
class="math inline">\(i(l≤i≤r)\)</span>，将 <span
class="math inline">\(a_i\)</span> 乘上 <span
class="math inline">\(x\)</span>。</p></li>
<li><p><code>TOTIENT l r</code>，求出 <span
class="math inline">\(φ(∏_{i=l}^ra_i)\)</span>，</p>
<p>其中 <span class="math inline">\(φ\)</span> 表示欧拉函数，<span
class="math inline">\(φ(n)\)</span> 的定义为 <span
class="math inline">\(1…n\)</span> 中与 <span
class="math inline">\(n\)</span> 互质的数的个数。</p></li>
</ol>
</blockquote>
<p>注意：欧拉函数虽然是积性函数，但不完全是：</p>
<ul>
<li><strong>若 <span class="math inline">\(a ,
b\)</span>互质</strong>，则$ φ ( a b ) = φ ( a ) φ ( b ) $</li>
<li><img src="https://img-blog.csdnimg.cn/img_convert/c702391c2c83a74d452f807c17308002.png" alt="img" style="zoom:50%;" /></li>
</ul>
<p>所以实际上我们只用维护有哪些质因子就可以了。</p>
<p>然后 <span class="math inline">\(300\)</span> 以内的质因子只有 <span
class="math inline">\(62\)</span> 个，直接状压就可以了。</p>
<p>然后再维护一个区间乘积就可以了。</p>
<h1 id="p4839-p哥的桶">P4839 P哥的桶</h1>
<blockquote>
<p>维护一个集合序列，支持单点插入，区间查询最大异或和。</p>
</blockquote>
<p>最大异或和？线性基！</p>
<p>那么就是普通的线性基插入，线性基合并了。</p>
<h1 id="cf515e-drazil-and-park">CF515E Drazil and Park</h1>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(i\)</span> 到点 <span
class="math inline">\(i+1\)</span> 的距离 <span
class="math inline">\(d[i]\)</span>，每个点有一个权值 <span
class="math inline">\(h[i]\)</span>。现在有 <span
class="math inline">\(m\)</span> 组询问，每次询问 <span
class="math inline">\([l,r]\)</span> 内两点 <span
class="math inline">\(x,y\)</span>， 使得 <span
class="math inline">\(2×(hx+hy)+dis(x,y)\)</span> 最大。其中 <span
class="math inline">\(dis(x,y)\)</span> 表示 <span
class="math inline">\(x\)</span> 到 <span
class="math inline">\(y\)</span> 的距离。</p>
</blockquote>
<p>考虑式子 <span class="math inline">\(2\times h_x + 2\times h_y
+dis(x,y)\)</span>。明显是要拆掉的。</p>
<p>第一步：拆掉<span class="math inline">\(dis(x,y)\)</span> <span
class="math inline">\(\rightarrow\)</span> <span
class="math inline">\(sum[x]-sum[y]\)</span></p>
<p>第二部：分离式子<span class="math inline">\(\rightarrow\)</span>
<span class="math inline">\(sum[x]+2\times h_x - (sum[y]-2\times
h_y)\)</span></p>
<p>那么很明显每一个点我们维护一个 <span
class="math inline">\(sum[i]+2\times h_i\)</span>，一个 <span
class="math inline">\(sum[i]-2\times h_i\)</span></p>
<p>那么我们就在一个区间内找到一个最大的<span
class="math inline">\(A\)</span>式子，最小的<span
class="math inline">\(B\)</span>式子就可以了。</p>
<p>然后考虑如何处理<span
class="math inline">\(A，B\)</span>在一个点上的问题，那么我们就先删掉这个相同点，再找一遍最大最小值就可以了。</p>
<h1 id="cf522d-closest-equals">CF522D Closest Equals</h1>
<blockquote>
<p>现在有一个序列 <span
class="math inline">\(a_1,a_2,...,a_n\)</span>，还有 <span
class="math inline">\(m\)</span> 个查询 <span
class="math inline">\(l_j,r_j (1≤l_j≤r_j≤n)\)</span>
。对于每一个查询，请找出距离最近的两个元素 <span
class="math inline">\(a_x和 a_y(x≠y)\)</span> ，并且满足以下条件：</p>
<p><span class="math inline">\(l_j≤x,y≤r_j\)</span>;</p>
<p><span class="math inline">\(a_x=a_y\)</span></p>
</blockquote>
<p>看到最近的两个元素，可以想到 <span
class="math inline">\(HH的项链\)</span>，具体怎么搞呢？</p>
<p>我们可以考虑把询问全部离线到右端点，然后假设我们当前扫描到了 <span
class="math inline">\(i\)</span> ，我们就把 <span
class="math inline">\(pre[i]\)</span>的位置更新为 <span
class="math inline">\(i-pre[i]\)</span> 一定注意是更新到 <span
class="math inline">\(pre[i]\)</span> 而不是 <span
class="math inline">\(i\)</span> ，画画图就能懂了。</p>
<p>那么询问就是区间最小值了。</p>
<h1 id="p5386-cnoi2019数字游戏">P5386 [CNOI2019]数字游戏</h1>
<blockquote>
<p>给定一个排列，多次询问，求一个区间 <span
class="math inline">\([l,r]\)</span> 有多少个子区间的值都在区间 <span
class="math inline">\([x,y]\)</span> 内。</p>
</blockquote>
<p>首先容易发现莫队是不好做的，但是我们可以考虑在值域上莫队，那么 <span
class="math inline">\(x,y\)</span> 的限制就被我们消除了，剩下的是 <span
class="math inline">\(l,r\)</span> 的问题了。</p>
<p>然后我们可以这样理解，我们现在序列上有一些 <span
class="math inline">\(1\)</span>，一段连续的 <span
class="math inline">\(1\)</span> 的贡献是 <span
class="math inline">\(\frac {len\times
(len-1)}{2}\)</span>，然后我们要求 <span
class="math inline">\([l,r]\)</span> 的贡献。</p>
<p>首先第一反应是线段树维护，但是这样会多一个 <span
class="math inline">\(log\)</span> 显然过不去.......</p>
<p>那么我们考虑<span class="math inline">\(O(1)\)</span>修改，<span
class="math inline">\(O(\sqrt
n)\)</span>的查询，可以想到分块解决，但是要支持撤回。</p>
<p>具体的维护方法可以看<a
target="_blank" rel="noopener" href="https://383791.blog.luogu.org/solution-p5386">代码</a></p>
<h1 id="cf1771f-hossam-and-range-minimum-query">CF1771F Hossam and Range
Minimum Query</h1>
<blockquote>
<ul>
<li><p>给你一个长度为 <span class="math inline">\(n\)</span>
的非负整数序列 <span class="math inline">\(a\)</span>。</p></li>
<li><p>有 <span class="math inline">\(q\)</span> 次询问，每次询问 <span
class="math inline">\([l,r]\)</span>
中满足出现次数为<strong>奇数</strong>的数当中，<strong>最小</strong>的那个是哪个数，不存在则输出
<span class="math inline">\(0\)</span></p></li>
<li><p>强制在线</p></li>
</ul>
</blockquote>
<p>考虑主席树，然后思考怎么快速判断一个区间内是否有出现次数为奇数的数。</p>
<ul>
<li>异或 <span class="math inline">\(HASH\)</span>
，给每一个数字赋一个随机权值，那么有结论，一个区间如果存在出现次数为奇数的数，显然他异或值不为
<span class="math inline">\(0\)</span>。</li>
</ul>
<p>注意这里的主席树是值域上的，<span
class="math inline">\(root[i]\)</span> 表示前缀异或 <span
class="math inline">\([1,i]\)</span> 的情况，查询的时候就查询<span
class="math inline">\(root[r]\)</span> 和 <span
class="math inline">\(root[l-1]\)</span> 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lval=tree[tree[p1].lc].val^tree[tree[p2].lc].val;</span><br></pre></td></tr></table></figure>
<h1 id="cf1767f-two-subtrees">CF1767F Two Subtrees</h1>
<blockquote>
<p>给你一棵有根树，每次给出两个子树（可能有交），求这两个子树中所有的点权的最小众数。如果一个点被两个子树覆盖算两次。</p>
</blockquote>
<p>区间众数是经典的不可以<span
class="math inline">\(polylog\)</span>的问题，通用解法是莫队或者摩尔投票。</p>
<blockquote>
<p><span class="math inline">\(polylog:\)</span><span
class="math inline">\(logn\)</span>，<span class="math inline">\(log^2
n\)</span>，<span class="math inline">\(log^3 n\)</span>。但<span
class="math inline">\(logn\times \sqrt n\)</span>不算</p>
</blockquote>
<p>第一想法是把树拍平，然后跑莫队，但是这样会丢失树上的一些性质。</p>
<p>可以考虑<span class="math inline">\(dsu\)</span> <span
class="math inline">\(on\)</span> <span
class="math inline">\(tree\)</span>
的实现过程，轻子树暴力重子树保留，这给了我们很好的一个莫队顺序，</p>
<h1 id="cf739c">CF739C</h1>
<blockquote>
<p>现在有 <span class="math inline">\(n\)</span> 个数，<span
class="math inline">\(m\)</span>
个操作，<strong>每次区间加一个数</strong>，对于<strong>每一次</strong>操作，你要找出<strong>最长</strong>的
<span class="math inline">\(a_l...a_r\)</span> ，满足</p>
<p><span
class="math inline">\(∃k ⁣∈ ⁣[l,r],al&lt;al+1&lt;al+2&lt;...&lt;ak&gt;ak+1&gt;ak+2&gt;...&gt;ar\)</span></p>
<p>输出其长度</p>
</blockquote>
<figure>
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/s1sza3mm.png?x-oss-process=image/resize,m_lfit,h_350,w_400"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>要维护的东西是：</p>
<ol type="1">
<li>左右端点的值（<span
class="math inline">\(lval,rval\)</span>）。这是用于左右区间拼接时判断边界大小关系的。</li>
<li>以左端点开始的最长单减子段（<span
class="math inline">\(iseq\)</span>）。</li>
<li>以右端点结束的最长单增子段（<span
class="math inline">\(dseq\)</span>）。</li>
<li>以左端点开始的最长单峰子段（<span
class="math inline">\(lans\)</span>）。</li>
<li>以右端点结束的最长单峰子段（<span
class="math inline">\(rans\)</span>）。<span
class="math inline">\(2,3,4,5\)</span>
都是用来拼接整个区间的单峰区间的。后面会详细讲到。</li>
<li>整个区间的最长单峰区间（<span
class="math inline">\(ans\)</span>）。</li>
<li>万年不变的懒标记（<span class="math inline">\(tag\)</span>）。</li>
</ol>
<p><del>有点ex</del></p>
<h1 id="cf718c-sasha-and-array">CF718C Sasha and Array</h1>
<blockquote>
<p>在本题中，我们用 <span class="math inline">\(fi\)</span> 来表示第
<span class="math inline">\(i\)</span> 个斐波那契数（<span
class="math inline">\(f1=f2=1,fi=fi−1+fi−2(i≥3)\)</span>）。</p>
<p>给定一个 <span class="math inline">\(n\)</span> 个数的序列 <span
class="math inline">\(a\)</span>。有 <span
class="math inline">\(m\)</span> 次操作，操作有两种：</p>
<ol type="1">
<li>将 <span class="math inline">\(al∼ar\)</span> 加上 <span
class="math inline">\(x\)</span>。</li>
<li>求$ (∑<em>{i=l}^{r}f</em>{a_i}) mod (1e9+7)$。</li>
</ol>
</blockquote>
<p>由于是斐波那契所以想到矩阵维护一下，然后矩阵有一个性质：</p>
<p><span class="math inline">\(a\times b+a\times c=a\times
(b+c)\)</span></p>
<p>所以区间加，就变成了区间乘矩阵了。</p>
<h1 id="cf803g-periodic-rmq-problem">CF803G Periodic RMQ Problem</h1>
<blockquote>
<p>给你一个序列aa 让你支持</p>
<p><span class="math inline">\(1\quad l，r，x\)</span> 区间赋值</p>
<p><span class="math inline">\(2\quad l，r\)</span> 询问区间最小值</p>
<p>我们觉得这个问题太水了,所以我们不会给你序列 <span
class="math inline">\(a\)</span></p>
<p>而是给你序列一个长度为 <span class="math inline">\(n\)</span> 的序列
<span class="math inline">\(b\)</span> ,把 <span
class="math inline">\(b\)</span> 复制粘贴 <span
class="math inline">\(k\)</span> 次就可以得到 <span
class="math inline">\(a\)</span></p>
</blockquote>
<p><del>似曾相识</del></p>
<p>直接动态开点权值线段树就可以了，然后利用<span
class="math inline">\(ST\)</span>表进行新建点的时候的初始化。</p>
<h1 id="cf911g-mass-change-queries">CF911G Mass Change Queries</h1>
<blockquote>
<p>给出一个数列,有<span
class="math inline">\(q\)</span>个操作,每种操作是把区间<span
class="math inline">\([l,r]\)</span>中等于<span
class="math inline">\(x\)</span>的数改成<span
class="math inline">\(y\)</span>.输出<span
class="math inline">\(q\)</span>步操作完的数列.</p>
</blockquote>
<p>因为值域只有<span
class="math inline">\(100\)</span>，所以可以建立<span
class="math inline">\(100\)</span>
棵线段树出来，那么某个值在一个区间里有值，当且仅当这棵线段树在这个区间里有点。</p>
<p>那么在把<span class="math inline">\(x\)</span> 变为 <span
class="math inline">\(y\)</span> 的时候，就相当于是把 <span
class="math inline">\(x\)</span> 的线段树在这个区间里的点移动到线段树
<span class="math inline">\(y\)</span> 上面去，也就是线段树合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!a)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; y <span class="keyword">or</span> r &lt; x)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= x <span class="keyword">and</span> r &lt;= y) &#123;</span><br><span class="line">		b = <span class="built_in">merge</span>(a , b);</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">		b = ++cnt;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">modify</span>(lson[a],lson[b],l,mid,x,y);</span><br><span class="line">	<span class="built_in">modify</span>(rson[a],rson[b],mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="p4062-yazid的新生舞会">P4062 Yazid的新生舞会</h1>
<blockquote>
<p>求有多少个子区间内的众数在该子区间的出现次数严格大于 <span
class="math inline">\(\frac{r−l+1}{2}\)</span></p>
</blockquote>
<p>区间众数，无法<span
class="math inline">\(polylog\)</span>.....吗？注意这里的众数是绝对众数！</p>
<p><del>经典题</del></p>
<p>所以我们考虑枚举众数，然后考虑怎么计算他的贡献，我们发现，如果把是该数的位置赋值为<span
class="math inline">\(1\)</span>，不是该数的位置赋值为 <span
class="math inline">\(0\)</span>，那么<span
class="math inline">\(l,r\)</span> 能成为众数的条件就是 <span
class="math inline">\(S_r-S_l&gt;r-l-(S_r-S_l)\)</span>。拆掉式子就是<span
class="math inline">\(2S_r-r&gt;2S_l-l\)</span>，那么问题变成了求全局顺序对个数。</p>
<p>如果我们每一次都是<span
class="math inline">\(O(nlogn)\)</span>的去做这个东西，显然不可行，于是考虑找性质。</p>
<p>我们发现对于前缀和数组<span
class="math inline">\(S\)</span>，一定是被拆成了一段一段等差数列的，例如：</p>
<p><span
class="math inline">\(0,-1,-2/-1,-2,-3/-2,-3/-2/-1,-2\)</span></p>
<p>可以发现在同一段里面是没有贡献的，而且这样的关键点加起来是<span
class="math inline">\(O(n)\)</span>的，是非常好的性质。</p>
<p>记 <span class="math inline">\(T_i\)</span> 表示权值的前缀和，即
<span class="math inline">\(T_i=∑_{j=1}^i c_i\)</span>。对段内每个位置的
<span class="math inline">\(P_i\)</span> ，我们得到的贡献是 <span
class="math inline">\(T_{P_i−1}\)</span>。也就是说，对整个段内 <span
class="math inline">\([x,y]\)</span> 这些数，总贡献是 <span
class="math inline">\(∑_{i=x−1}^{y−1}Ti\)</span>。记 <span
class="math inline">\(G_i\)</span> 表示权值的前缀和的前缀和，即 <span
class="math inline">\(G_i=∑_{j=1}^{i}T_j\)</span>，那么总贡献可以表示为
<span class="math inline">\(G_{y−1}−G_{x−1}\)</span>。</p>
<p>那么问题就变成了区间加法，区间求二阶前缀和。</p>
<p>可以考虑线段树维护权值的前缀和 <span
class="math inline">\(T_i\)</span> ，这样在 <span
class="math inline">\([x,y]\)</span> 上的区间加 <span
class="math inline">\(1\)</span> 就变成了：在 <span
class="math inline">\([x,y]\)</span> 上加等差数列 <span
class="math inline">\(1,2,3,…,y−x+1\)</span>，在 <span
class="math inline">\([y+1,2n+1]\)</span> 上加上 <span
class="math inline">\(y−x+1\)</span>。后者也可看成是公差为 <span
class="math inline">\(0\)</span> 的等差数列。</p>
<p>然后区间求和就做完了。</p>
<h1 id="p4314-cpu监控">P4314 CPU监控</h1>
<blockquote>
<p>区间加，区间赋值，区间最大值，区间历史最大值。</p>
</blockquote>
<p>吉司机线段树？</p>
<p><del>其实不用太麻烦</del></p>
<p>这里首先有一个技巧，就是说如果有区间加和区间赋值操作，那么在第一次的区间赋值操作之后，后面所有的区间加操作都可以视作区间赋值操作。</p>
<p>这样，一个区间的操作序列就被劈成了两半，一半全是区间加，另一半全是区间赋值。</p>
<p>那么怎么维护区间历史最大值呢？我们先考虑左半边，那么我们可以维护一个上次下放之后的最大加和，上次下方之后的最大赋值，在此之前先维护一个“是否进行过区间赋值的<span
class="math inline">\(tag\)</span>"，假如我们当前有一个区间加，就先看<span
class="math inline">\(vis\)</span>是否为<span
class="math inline">\(1\)</span>，是就直接更新最大赋值，否就更新最大加和，区间赋值也是同理。</p>
<p>更详细的可以看<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/He-Ren/solution-p4314">这里</a></p>
<h1 id="cf840d-destiny">CF840D Destiny</h1>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个元素，<span
class="math inline">\(m\)</span> 次询问。</p>
<p>每次给出三个参数 <span class="math inline">\(l,r,k\)</span>，询问区间
<span class="math inline">\([l,r]\)</span>
内是否存在出现次数严格大于<span
class="math inline">\(\frac{r−l+1}{k}\)</span>
的数。如果存在就输出最小的那个 <span
class="math inline">\(ans\)</span>，否则输出 <span
class="math inline">\(-1\)</span>.</p>
</blockquote>
<p>建立主席树，然后两个版本相减，然后递归左右子树，如果<strong>总次数</strong>超过目标说明<strong>很有可能这个子区间存在答案</strong>，当然会出现实际不存在的情况，但是最多只会有<span
class="math inline">\(k\)</span>次这种情况。如图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/odhrtl4f.png?x-oss-process=image/resize,m_lfit,h_170,w_225" alt="img" style="zoom:200%;" /></p>
<h1 id="cf817f-mex-queries">CF817F Mex Queries</h1>
<blockquote>
<ul>
<li>将 l 到 r 的区间用 1 覆盖</li>
<li>将 l 到 r 的区间用 0 覆盖</li>
<li>将 l 到 r 的区间取反</li>
</ul>
<p>区间的初始值都为 0。</p>
<p>在每次操作后输出第一个 0 的下标。</p>
</blockquote>
<p>虽然用动态开点线段树和线段树上二分也可以做，但是我们还是要学习珂朵莉树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> val;<span class="comment">//区间端点、权值</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;t) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> l&lt;t.l;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line">se it,itl,itr;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> se <span class="title">split</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    it=s.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(&#123;pos&#125;));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">		<span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="type">int</span> l=it-&gt;l,r=it-&gt;r,v=it-&gt;val;</span><br><span class="line">    s.<span class="built_in">erase</span>(it);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">node</span>(&#123;l,pos<span class="number">-1</span>,v&#125;));</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">insert</span>(<span class="built_in">node</span>(&#123;pos,r,v&#125;)).first;</span><br><span class="line">&#125;<span class="comment">//分裂成 2 个区间</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    itr=<span class="built_in">split</span>(r+<span class="number">1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="comment">//这里特别注意顺序不要颠倒了！</span></span><br><span class="line">    s.<span class="built_in">erase</span>(itl,itr);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">node</span>(&#123;l,r,val&#125;));</span><br><span class="line">&#125;<span class="comment">//区间覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rever</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    itr=<span class="built_in">split</span>(r+<span class="number">1</span>),itl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(se it=itl;it!=itr;++it)</span><br><span class="line">        it-&gt;val=!it-&gt;val;</span><br><span class="line">&#125;<span class="comment">//区间取反</span></span><br></pre></td></tr></table></figure>
<h1 id="cf1725e-electrical-efficiency">CF1725E Electrical
Efficiency</h1>
<blockquote>
<p>树上 <span class="math inline">\(n\)</span> 个点，每个点有点权 <span
class="math inline">\(a_i\)</span>。对于一个三元组 <span
class="math inline">\((x,y,z)\)</span> 满足$ 1≤x&lt;y&lt;z≤n$，定义
<span class="math inline">\(f(x,y,z)\)</span>
为树上连通这三个点的连通块的最小边数（即三个点两两间路径的并的边数），<span
class="math inline">\(g(x,y,z)\)</span>为 <span
class="math inline">\(gcd⁡(a_x,a_y,a_z)\)</span>
所含的不同质因子个数，求 <span
class="math inline">\(∑f(x,y,z)×g(x,y,z)\)</span></p>
</blockquote>
<ul>
<li><p>原答案等价于<span
class="math inline">\(∑_{d∈P}∑f(x,y,z)[d∣gcd(a_x,a_y,a_z)]\)</span>。</p></li>
<li><p><span
class="math inline">\(f(x,y,z)=\frac{dis(x,y)+dis(x,z)+dis(y,z)}{2}\)</span></p></li>
</ul>
<p>所以<span
class="math inline">\(∑f(x,y,z)=\frac{(n−2)}{2}∑dis(x,y)\)</span>。</p>
<p>然后枚举质数 <span class="math inline">\(p\)</span>，把所有 <span
class="math inline">\(p∣a_i\)</span> 的点拎出来建虚树，然后一次 <span
class="math inline">\(dfs\)</span>
算出任意两点间的距离之和（注意只计算关键点的贡献，对于保持树的形态加入的点不算）。</p>
<blockquote>
<p>左偏树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> rt[x]==x?x:rt[x]=<span class="built_in">find</span>(rt[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x+y;</span><br><span class="line"> <span class="keyword">if</span>(v[y]&lt;v[x])<span class="built_in">swap</span>(x,y);</span><br><span class="line"> rc[x]=<span class="built_in">merge</span>(rc[x],y);</span><br><span class="line"> <span class="keyword">if</span>(dist[lc[x]]&lt;dist[rc[x]])<span class="built_in">swap</span>(lc[x],rc[x]);</span><br><span class="line"> dist[x]=dist[rc[x]]+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="p3224-永无乡">P3224 永无乡</h1>
<blockquote>
<p><code>B x y</code> 表示在岛 <span class="math inline">\(x\)</span>
与岛 <span class="math inline">\(y\)</span> 之间修建一座新桥。</p>
<p><code>Q x k</code> 表示询问当前所与岛 <span
class="math inline">\(x\)</span> 连通的岛中重要度排名第 <span
class="math inline">\(k\)</span>
小的岛是哪座，请你输出那个岛的编号。</p>
</blockquote>
<p>可以考虑并查集和线段树合并，具体来说，每一个连通块在 <span
class="math inline">\(rt\)</span>
处都会有一个线段树，那么合并两个连通块就变成了合并两棵线段树，查询就是查询第
<span class="math inline">\(k\)</span> 大。</p>
<h1 id="p3521-pot-tree-rotation">P3521 POT-Tree Rotation</h1>
<blockquote>
<p>给定一颗有 <span class="math inline">\(n\)</span>
个<strong>叶节点</strong>的二叉树。每个叶节点都有一个权值 <span
class="math inline">\(p_i\)</span>（注意，根不是叶节点），所有叶节点的权值构成了一个
<span class="math inline">\(1∼n\)</span> 的排列。
对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。
现在你可以任选一些节点，交换这些节点的左右子树。
在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为
<span class="math inline">\(n\)</span>
的排列，你需要最小化这个排列的逆序对数。</p>
</blockquote>
<p>一定要注意！每个节点交不交换都是互不影响的！这就说明我们每个点能换就要换，不能换就不换！</p>
<p>那么问题就变成怎么快速求逆序对了。</p>
<p>这个题的解决方法和分治求逆序对是很像的，我们可以考虑线段树合并，那么：</p>
<p>用 <span class="math inline">\(p\)</span> 表示左子树，<span
class="math inline">\(q\)</span> 表示右子树。<span
class="math inline">\(ls\)</span> 表示左子节点，<span
class="math inline">\(rs\)</span> 表示右子节点。</p>
<p>很明显，对于除了<strong>叶节点</strong>的每一个节点：</p>
<ol type="1">
<li>如果不交换： <span
class="math inline">\(u+=[p.rs].size∗[q.ls].size\)</span></li>
<li>如果交换： <span
class="math inline">\(v+=[p.ls].size∗[q.rs].size\)</span></li>
</ol>
<p>这里的节点是指值域线段树上的节点。</p>
<h1 id="p2824-heoi2016tjoi2016排序">P2824 [HEOI2016/TJOI2016]排序</h1>
<blockquote>
<ul>
<li><code>0 l r</code> 表示将区间 <span
class="math inline">\([l,r]\)</span> 的数字升序排序</li>
<li><code>1 l r</code> 表示将区间 <span
class="math inline">\([l,r]\)</span> 的数字降序排序</li>
</ul>
<p>注意，这里是对<strong>下标</strong>在区间 <span
class="math inline">\([l,r]\)</span> 内的数排序。 最后询问第 <span
class="math inline">\(q\)</span> 位置上的数字。</p>
</blockquote>
<p>因为只会询问一个位置，所以可以二分答案，那么问题就变成了区间赋<span
class="math inline">\(0,1\)</span>值区间求和了。</p>
<p>如果查询的位置是<span class="math inline">\(1\)</span>，就<span
class="math inline">\(l=mid+1\)</span>，否则<span
class="math inline">\(r=mid-1\)</span></p>
<p>当然因为是区间推平和区间求和，也可以<span
class="math inline">\(ODT\)</span></p>
<h1 id="cf558e-a-simple-task">CF558E A Simple Task</h1>
<blockquote>
<p>给定一个长度不超过<span
class="math inline">\(1e5\)</span>的字符串，每次给定区间，要求区间升序降序排序</p>
</blockquote>
<p>很经典的一道题目，考虑建树，每个点维护<span
class="math inline">\(26\)</span>个字母在当前区间的个数，那么排序的时候相当于是先区间求出数组，然后再区间赋值即可。</p>
<h1 id="p3437-poi2006tet-tetris-3d">P3437 [POI2006]TET-Tetris 3D</h1>
<blockquote>
<p>二维区间赋值，一次整体最值。</p>
</blockquote>
<p>看一看数据范围，显然的二维线段树。</p>
<p>那么我们考虑怎么维护，我们发现如果方块掉落在了一片参差不齐的位置，那么我们最后一定是将这一片区间先找到最值，然后区间赋值为最大值<span
class="math inline">\(+k\)</span>。</p>
<p>当然需要标记永久化一下。</p>
<h1 id="p5524-ynoi2012noip2015充满了希望">P5524
[Ynoi2012]NOIP2015充满了希望</h1>
<blockquote>
<p>给一个长为 <span class="math inline">\(n\)</span> 的序列，有 <span
class="math inline">\(m\)</span> 个操作，操作编号从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(m\)</span>，每个操作为：</p>
<p><code>1 x y</code>：将序列位置为 <span
class="math inline">\(x,y\)</span> 的两个元素交换。</p>
<p><code>2 l r x</code>：将序列区间 <span
class="math inline">\([l,r]\)</span> 内所有元素修改为 <span
class="math inline">\(x\)</span>。</p>
<p><code>3 x</code>：查询序列 <span class="math inline">\(x\)</span>
位置的值。</p>
<p>现在有 <span class="math inline">\(q\)</span>
次查询，每次查询给出一个操作的区间 <span
class="math inline">\([l,r]\)</span>：</p>
<p>先将序列中的元素全部置为 <span
class="math inline">\(0\)</span>，之后依次进行从 <span
class="math inline">\(l\)</span> 到 <span
class="math inline">\(r\)</span> 的所有操作，求出所有这些操作中所有
<span class="math inline">\(3\)</span> 操作的答案的和。</p>
<p>查询之间独立。</p>
</blockquote>
<p>看到这种区间推平，就容易想到对于每一个位置都找到最后一个影响到它的操作的位置。</p>
<p>那么我们对于所有的 <span class="math inline">\(3\)</span>
操作都找到影响到他的最前面的操作，假设为<span
class="math inline">\(pos\)</span>，那么在询问的时候如果 <span
class="math inline">\(l\)</span> 在 <span
class="math inline">\(pos\)</span> 右边，那么当前位置是没有值的。</p>
<p>那么现在问题就变成了，每一个位置有一个 <span
class="math inline">\(pos\)</span> 值一个 <span
class="math inline">\(val\)</span>值，<span
class="math inline">\(q\)</span>次询问，每次询问在<span
class="math inline">\(l,r\)</span>中，<span
class="math inline">\(pos_i\)</span>大于 <span
class="math inline">\(l\)</span> 的 <span
class="math inline">\(val_i\)</span> 的和。</p>
<p>直接树状数组就可以了。</p>
<h1 id="p4168-violet蒲公英">P4168 [Violet]蒲公英</h1>
<blockquote>
<p>区间众数，强制在线</p>
<p><span class="math inline">\(n\le40000\)</span>，<span
class="math inline">\(m\le 50000\)</span> ，<span
class="math inline">\(w\le 10^9\)</span></p>
</blockquote>
<p>可以考虑预处理两个数组：</p>
<p><span class="math inline">\(p[i][j]\)</span>表示块 <span
class="math inline">\(i\)</span> 到块 <span
class="math inline">\(j\)</span> 的最小众数是谁。</p>
<p><span class="math inline">\(s[i][j]\)</span>表示前<span
class="math inline">\(i\)</span>个块中数 <span
class="math inline">\(j\)</span> 出现的次数。</p>
<p>有这两个数组就可以处理了</p>
<h1 id="p5048-ynoi2019-yuno-loves-sqrt-technology-iii">P5048 [Ynoi2019]
Yuno loves sqrt technology III</h1>
<blockquote>
<p>区间众数，强制在线</p>
<p><span class="math inline">\(n\le500000\)</span>，<span
class="math inline">\(m\le 500000\)</span> ，<span
class="math inline">\(w\le 10^9\)</span></p>
</blockquote>
<p>数据范围太大了，显然我们的<span
class="math inline">\(s[i][j]\)</span>开不下了，那么我们还是预处理出<span
class="math inline">\(p[i][j]\)</span>数组，然后考虑散块怎么处理。</p>
<p>我们可以这样考虑，我们先使用<span
class="math inline">\(n\)</span>个<span
class="math inline">\(vector[i]\)</span>记录数<span
class="math inline">\(i\)</span>出现的位置集合。</p>
<p>然后记<span class="math inline">\(p_i\)</span>表示<span
class="math inline">\(i\)</span>这位上的数在<span
class="math inline">\(vector[a_i]\)</span>是第几个，然后在询问的时候还是先把<span
class="math inline">\(s[bl+1][br-1]\)</span>找出来，再考虑散块是否会成为众数，设<span
class="math inline">\(s[bl+1][br-1]=T\)</span>，注意<span
class="math inline">\(T\)</span>是出现次数，那么散块想要成为众数，必须出现大于<span
class="math inline">\(T\)</span>次，也就是说，出现第<span
class="math inline">\(T+now\)</span>次的数要在<span
class="math inline">\(l,r\)</span>范围内。</p>
<h1 id="p1712-noi2016-区间">P1712 [NOI2016] 区间</h1>
<blockquote>
<p>在数轴上有 <span class="math inline">\(n\)</span> 个闭区间从 <span
class="math inline">\(1\)</span> 至 <span
class="math inline">\(n\)</span> 编号，第 <span
class="math inline">\(i\)</span> 个闭区间为 <span
class="math inline">\([l_i,r_i]\)</span> 。</p>
<p>现在要从中选出 <span class="math inline">\(m\)</span> 个区间，使得这
<span class="math inline">\(m\)</span>
个区间共同包含至少一个位置。换句话说，就是使得存在一个 <span
class="math inline">\(x\)</span> ，使得对于每一个被选中的区间 <span
class="math inline">\([l_i,r_i]\)</span>，都有 <span
class="math inline">\(l_i≤x≤r_i\)</span> 。</p>
<p>对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。</p>
<p>区间 <span class="math inline">\([l_i,r_i]\)</span> 的长度定义为
<span class="math inline">\((r_i−l_i)\)</span>
，即等于它的右端点的值减去左端点的值。</p>
<p>求所有合法方案中最小的花费。如果不存在合法的方案，输出 <span
class="math inline">\(−1\)</span>。</p>
</blockquote>
<p>双指针，左端点固定时，右端点移动，如果有一个点被覆盖了超过<span
class="math inline">\(k\)</span>次就停止。</p>
<p>固定右端点也是可以的，那么就变成了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	sgt.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, tot, a[i].l, a[i].r, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (sgt.<span class="built_in">query_all</span>() &gt;= m) &#123;</span><br><span class="line">		<span class="built_in">chkmin</span>(ret, a[i].length - a[tmpl].length);</span><br><span class="line">		sgt.<span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, tot, a[tmpl].l, a[tmpl].r, <span class="number">-1</span>);</span><br><span class="line">		tmpl++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="p3793-由乃与大母神原型和偶像崇拜">P3793
由乃与大母神原型和偶像崇拜</h1>
<blockquote>
<p>给你一个长为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(a\)</span></p>
<p>每次两个操作：</p>
<ol type="1">
<li>修改 <span class="math inline">\(x\)</span> 位置的值为 <span
class="math inline">\(y\)</span></li>
<li>查询区间 <span class="math inline">\([l,r]\)</span>
是否可以重排为值域上连续的一段</li>
</ol>
</blockquote>
<p>这个题很神奇，我们发现这个东西很难维护，于是考虑有没有什么正确率高一些的维护方法。</p>
<p>那么我们可以维护线段树区间最小值，区间最大值和区间平方和。</p>
<p>这里补一个连续平方和公式： <span class="math display">\[
1^2+2^2+...+n^2 \\\\ =1\times(2-1)+2\times(3-1)+...+n\times(n+1-1)
\]</span> 因为<span
class="math inline">\(n\times(n+1)=\frac{1}{3}[n(n+1)(n+2)-(n-1)n(n+1)]\)</span>
<span class="math display">\[
S=\frac{1}{3}[1\times2\times3-0\times1\times2]+\frac{1}{3}[2\times3\times4-1\times2\times3]+...
\]</span></p>
<p><span class="math display">\[
=\frac{1}{3}[n(n+1)(n+2)]-\frac{n(n+1)}{2} \\\\
=\frac{n\times(n+1)\times(2n+1)}{6}
\]</span></p>
<h1 id="p2633-count-on-a-tree">P2633 Count on a tree</h1>
<blockquote>
<p>给定一棵树，每次询问一条路径上标号第 <span
class="math inline">\(k\)</span> 小的点是谁</p>
</blockquote>
<p>可以考虑可持久化线段树，我们设在节点 <span
class="math inline">\(i\)</span> 的主席树是 <span
class="math inline">\(s[i]\)</span>，那么答案就是： <span
class="math display">\[
s[u]+s[v]−s[lca(u,v)]−s[fa[lca(u,v)]]
\]</span> 的主席树的树。</p>
<p>然后我们没有必要真的一个一个加减把最后得到的树求出来，我们只需要在多个树上同时向左向右走就可以了（有点类似树套树的方法，参见<span
class="math inline">\(dynamic\)</span> <span
class="math inline">\(ranking\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(Node x, Node y, Node z, Node w, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum &gt;= k) <span class="keyword">return</span> <span class="built_in">query</span>(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(node[x.r], node[y.r], node[z.r], node[w.r], mid+<span class="number">1</span>, r, k - sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="p2839-middle">P2839 middle</h1>
<blockquote>
<p>回答 <span class="math inline">\(Q\)</span> 个这样的询问：<span
class="math inline">\(s\)</span> 的左端点在 <span
class="math inline">\([a,b]\)</span> 之间，右端点在 <span
class="math inline">\([c,d]\)</span> 之间的子区间中，最大的中位数。</p>
</blockquote>
<p>看到区间中位数，一定要反应过来是枚举<span
class="math inline">\(mid\)</span>，然后大于等于 <span
class="math inline">\(mid\)</span> 的赋值为 <span
class="math inline">\(1\)</span>，否则赋值为 <span
class="math inline">\(-1\)</span>，判断就直接判断和是否大于 <span
class="math inline">\(0\)</span> 就可以了。</p>
<p>但是我们有多次 <span
class="math inline">\(check\)</span>，所以要开一个主席树，<span
class="math inline">\(rt[i]\)</span>表示当前 <span
class="math inline">\(mid=i\)</span> 的时候数组内 <span
class="math inline">\(-1\)</span>和<span
class="math inline">\(1\)</span>的情况是什么样子的。</p>
<p>然后<span class="math inline">\(check\)</span>就是前区间<span
class="math inline">\(rmax\)</span> + 后区间<span
class="math inline">\(lmax +\)</span> 必选区间<span
class="math display">\[[b + 1, c - 1]\]</span>是否<span
class="math inline">\(&gt;=0\)</span></p>
<h1 id="p4577-fjoi2018-领导集团问题">P4577 [FJOI2018] 领导集团问题</h1>
<blockquote>
<p>给定一棵树，求<span class="math inline">\(求 ∣Smax∣使得 ∀i,j(ancestor
of i)∈S,wi≤wj\)</span></p>
</blockquote>
<p>可以设<span class="math inline">\(dp[u][x]\)</span>表示点 <span
class="math inline">\(u\)</span> 的子树中，大于<span
class="math inline">\(x\)</span> 选的节点全都大于 <span
class="math inline">\(x\)</span> 的最大子集大小</p>
<p>那么转移就是：</p>
<p><span
class="math inline">\(x∈[1,n],f(u,x)=∑_{v是u的儿子节点}f(v,x)\)</span></p>
<p><span
class="math inline">\(x∈[1,w_u],f(u,x)max⁡=∑_{v在u的儿子节点}f(v,w_u)+1\)</span></p>
<p>每个点用线段树维护第二维度。</p>
<p>那么问题就变成了区间对一个数取<span
class="math inline">\(max\)</span>（推平），区间加。</p>
<p>维护方式就是同时记录区间加和区间取<span
class="math inline">\(max\)</span>，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">seg_add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[x].sum+=v;</span><br><span class="line">    <span class="keyword">if</span>(t[x].assign!=<span class="number">-1</span>)</span><br><span class="line">    	t[x].assign+=v;</span><br><span class="line">    t[x].add+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   t[x].sum=<span class="built_in">max</span>(t[x].sum,v);</span><br><span class="line">   t[x].assign=<span class="built_in">max</span>(v,t[x].assign);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!t[k].lson) t[k].lson=<span class="built_in">getnode</span>();</span><br><span class="line">	<span class="keyword">if</span>(!t[k].rson) t[k].rson=<span class="built_in">getnode</span>();</span><br><span class="line">	<span class="keyword">if</span> (t[k].add)</span><br><span class="line">	&#123;</span><br><span class="line">	    t[t[k].lson].sum+=t[k].add;</span><br><span class="line">	    t[t[k].rson].sum+=t[k].add;</span><br><span class="line">	    t[t[k].lson].add+=t[k].add;</span><br><span class="line">	    t[t[k].rson].add+=t[k].add;</span><br><span class="line">	    t[t[k].lson].assign+=t[k].add;</span><br><span class="line">	    t[t[k].rson].assign+=t[k].add;</span><br><span class="line">	    t[k].add=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (t[k].assign != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    t[t[k].lson].sum=<span class="built_in">max</span>(t[k].assign,t[t[k].lson].sum);</span><br><span class="line">	    t[t[k].rson].sum=<span class="built_in">max</span>(t[k].assign,t[t[k].rson].sum);</span><br><span class="line">	    t[t[k].lson].assign=<span class="built_in">max</span>(t[k].assign,t[t[k].lson].assign);</span><br><span class="line">	    t[t[k].rson].assign=<span class="built_in">max</span>(t[k].assign,t[t[k].rson].assign);</span><br><span class="line">	    t[k].assign=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的原理是这样的：</p>
<figure>
<img src="E:\3_disk_c\DS\pics\null%20(3).png" alt="null (3)" />
<figcaption aria-hidden="true">null (3)</figcaption>
</figure>
<h1 id="p4331-sequence-数字序列">P4331 Sequence 数字序列</h1>
<blockquote>
<p>给定一个整数序列 <span class="math inline">\(a1,a2,⋅⋅⋅,an\)</span>
求出一个递增序列 <span
class="math inline">\(b1&lt;b2&lt;⋅⋅⋅&lt;bn\)</span>，使得序列<span
class="math inline">\(a_i\)</span>和 <span
class="math inline">\(b_i\)</span> 的各项之差的绝对值之和<span
class="math inline">\(∣a1−b1∣+∣a2−b2∣+⋅⋅⋅+∣an−bn∣\)</span> 最小。</p>
</blockquote>
<p>①：若原序列a满足 <span
class="math inline">\(a1&lt;a2&lt;…&lt;an\)</span>，显然最优情况为 <span
class="math inline">\(b_i=a_i\)</span></p>
<p>②：若原序列a满足 <span
class="math inline">\(a1&gt;a2&gt;…&gt;an\)</span>，显然最优情况为 <span
class="math inline">\(b_{mid}=x\)</span>（<span
class="math inline">\(x\)</span>为<span
class="math inline">\(a\)</span>中位数）</p>
<p>有了上述的两种情况，不难发现，整个 <span
class="math inline">\(a\)</span> 序列是尤一些单调区间组成。</p>
<p>所以我们可以将原序列a拆成若干个单调区间，最后再将答案合并。</p>
<p>我们可以重新找一个中位数来合并。</p>
<p>假设我们已经找到前 <span class="math inline">\(k\)</span>
个数的最优解，队列中有 <span class="math inline">\(cnt\)</span>
段区间，每段区间最优解为<span
class="math inline">\(w1,w2,…,wcnt\)</span>，现在要加入 <span
class="math inline">\(a_{k+1}\)</span>，并更新队列。</p>
<p>首先把 <span class="math inline">\(ak+1\)</span> 加入队尾，令 <span
class="math inline">\(w_{cnt+1}=a_{k+1}\)</span> 如果 <span
class="math inline">\(w_{cnt}&gt;w_{cnt+1}\)</span>，就将最后两个区间合并，并找出新区间的最优解。重复上述过程，直至满足
<span class="math inline">\(w\)</span> 单调递增。</p>
<h1 id="p3732-供给侧改革">P3732 供给侧改革</h1>
<blockquote>
<p>Anihc
国提高社会生产力水平，落实好以人民为中心的发展思想，决定进行供给侧结构性改革。</p>
<p>为了提高供给品质，你调查了某个产业近来 <span
class="math inline">\(n\)</span>
个时期的供求关系平衡情况，每个时期的情况都用 <span
class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 中的一个数字来表示。于是这就是—个长度为
<span class="math inline">\(n\)</span> 的 <span
class="math inline">\(\texttt{01}\)</span> 字符串 <span
class="math inline">\(S\)</span>。为了更好的了解这一些数据，你需要解决一些询问，我们令
<span class="math inline">\(\text{data}(L,R)\)</span> 表示：在字符串
<span class="math inline">\(S\)</span> 中，起始位置在 <span
class="math inline">\([L,R]\)</span>
之间的这些后缀之中，具有最长公共前缀的两个后缀的最长公共前缀的长度。</p>
<p>对于每一个询问 <span class="math inline">\(L,R\)</span>，求：</p>
<p><span class="math display">\[ans = \sum_{L \leqslant i &lt; R}
\text{data}(i,R)\]</span></p>
<p>由于你其实根本没有时间调查，所以这些数据都是乱编的，即串 <span
class="math inline">\(S\)</span> 中的每一位都是在 <span
class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span> 之间随机产生的。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/20/CDQ%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="starslight">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/03/20/CDQ%E5%88%86%E6%B2%BB/" class="post-title-link" itemprop="url">CDQ分治</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-20T00:00:00+08:00">2023-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-03-23 22:42:48" itemprop="dateModified" datetime="2023-03-23T22:42:48+08:00">2023-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="天使玩偶violet">天使玩偶Violet</h1>
<p>先按照时间维度分治理，然后只考虑一个点左下角的点，剩下的点旋转坐标系，把一个点转化为<span
class="math display">\[vx+vy\]</span>，就变成了在 <span
class="math display">\[vx_1&lt;vx_2\]</span> 且 <span
class="math display">\[vy_1&lt;vy_2\]</span> 的情况下求 <span
class="math display">\[vx_1+vx_2\]</span> 最大。</p>
<p>我们把在 <span class="math inline">\(mid\)</span> 左边的点的 <span
class="math inline">\(op=1\)</span> 的改成<span
class="math inline">\(3\)</span>，右边同理，再按照<span
class="math inline">\(x\)</span>轴排序，这样对于一个在操作<span
class="math inline">\(4\)</span>前面的操作<span
class="math inline">\(3\)</span>，他时间轴上显然早于<span
class="math inline">\(4\)</span>，在<span
class="math inline">\(x\)</span>轴上显然小于<span
class="math inline">\(4\)</span>，那么还剩一维<span
class="math inline">\(y\)</span>就考虑树状数组即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">600009</span>;</span><br><span class="line"><span class="type">int</span> n,m,x,y;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="type">int</span> ti,x,y,type;</span><br><span class="line">&#125;ls[N],q[N];</span><br><span class="line"><span class="type">int</span> pt,c[<span class="number">2000055</span>],ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="keyword">return</span> p&amp;(-p);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=<span class="number">1000010</span>;i+=<span class="built_in">lowbit</span>(i)) c[i]=<span class="built_in">max</span>(c[i],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=<span class="number">1000010</span>;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		<span class="keyword">if</span>(c[i]!=<span class="number">-0x3f3f3f3f</span>) c[i]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i)) res=<span class="built_in">max</span>(res,c[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxx=<span class="number">0</span>,maxy=<span class="number">0</span>;</span><br><span class="line">	pt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].type==<span class="number">2</span>)&#123;</span><br><span class="line">			maxx=<span class="built_in">max</span>(maxx,q[i].x);</span><br><span class="line">			maxy=<span class="built_in">max</span>(maxy,q[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].type==<span class="number">2</span> || (q[i].x&lt;=maxx &amp;&amp; q[i].y&lt;=maxy))</span><br><span class="line">			ls[++pt]=q[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cdq</span>(l,mid);</span><br><span class="line">	<span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="type">int</span> i=l;</span><br><span class="line">	<span class="type">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	vector&lt;point&gt; vc;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ls[i].x&lt;=ls[j].x)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ls[i].type==<span class="number">1</span>) <span class="built_in">update</span>(ls[i].y,ls[i].x+ls[i].y);</span><br><span class="line">			vc.<span class="built_in">push_back</span>(ls[i]);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(ls[j].type==<span class="number">2</span>) ans[ls[j].ti]=<span class="built_in">min</span>(ans[ls[j].ti],ls[j].x+ls[j].y-<span class="built_in">query</span>(ls[j].y));</span><br><span class="line">			vc.<span class="built_in">push_back</span>(ls[j]);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		vc.<span class="built_in">push_back</span>(ls[i]),i++;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ls[j].type==<span class="number">2</span>)&#123;</span><br><span class="line">			ans[ls[j].ti]=<span class="built_in">min</span>(ans[ls[j].ti],ls[j].x+ls[j].y-<span class="built_in">query</span>(ls[j].y));</span><br><span class="line">		&#125;</span><br><span class="line">		vc.<span class="built_in">push_back</span>(ls[j]);</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ls[i].type==<span class="number">1</span>)<span class="built_in">remove</span>(ls[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) ls[i]=vc[i-l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		x++,y++;q[i].ti=<span class="number">0</span>,q[i].x=x,q[i].y=y,q[i].type=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> op;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		x++,y++;q[i+n].ti=i,q[i+n].x=x,q[i+n].y=y,q[i+n].type=op;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000010</span>;i++) c[i]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="built_in">copy</span>(),<span class="built_in">cdq</span>(<span class="number">1</span>,pt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++) q[i].x=<span class="number">1000002</span>-q[i].x;</span><br><span class="line">	<span class="built_in">copy</span>(),<span class="built_in">cdq</span>(<span class="number">1</span>,pt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++) q[i].y=<span class="number">1000002</span>-q[i].y;</span><br><span class="line">	<span class="built_in">copy</span>(),<span class="built_in">cdq</span>(<span class="number">1</span>,pt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++) q[i].x=<span class="number">1000002</span>-q[i].x;</span><br><span class="line">	<span class="built_in">copy</span>(),<span class="built_in">cdq</span>(<span class="number">1</span>,pt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(ans[i]!=<span class="number">0x3f3f3f3f</span>) </span><br><span class="line">			cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="p3769-ch弱省胡策r2tatt">P3769 [CH弱省胡策R2]TATT</h1>
<p>题意：四维偏序</p>
<p>三维偏序的 <span class="math inline">\(CDQ\)</span> 本质就是把每个
<span class="math inline">\((x,y,z)\)</span> 转化若干为 <span
class="math inline">\((0,y,z)\)</span> 对 <span
class="math inline">\((1,y,z)\)</span>
的贡献。剩下的就是个经典二维偏序问题。</p>
<p>四维偏序中珂以沿用三维偏序中的思路。</p>
<p>把若干 <span class="math inline">\((x,y,z,w)\)</span> 分成 <span
class="math inline">\((0/1,0/1,z,w)\)</span>，然后计算 <span
class="math inline">\((0,0,z,w)\)</span> 对 <span
class="math inline">\((1,1,z,w)\)</span>的贡献。</p>
<p>注意以下两点：</p>
<ul>
<li><p>树状数组维护区间 <span class="math inline">\(max\)</span>
是在只加点不删除点的状况下是正确的。</p></li>
<li><p>在 <span class="math inline">\(CDQ\)</span>
时我们必须先递归计算左区间，算完左区间对右区间的贡献后在递归计算右区间，不然得出的值会变小。考虑这样一种贡献：左边对右边，右边对右边。</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,d,id;</span><br><span class="line">	<span class="type">int</span> w,ans;</span><br><span class="line">	<span class="type">int</span> grd;</span><br><span class="line">&#125;s[<span class="number">50009</span>],pt[<span class="number">50009</span>],ls[<span class="number">50009</span>];</span><br><span class="line"><span class="type">int</span> l[<span class="number">50009</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">50009</span>];</span><br><span class="line"><span class="type">int</span> pos1[<span class="number">50009</span>];</span><br><span class="line"><span class="type">int</span> pos2[<span class="number">50009</span>];</span><br><span class="line"><span class="type">int</span> tp;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node A,node B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.a==B.a)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.b==B.b)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A.c==B.c)</span><br><span class="line">				<span class="keyword">return</span> A.d&lt;B.d;</span><br><span class="line">			<span class="keyword">return</span> A.c&lt;B.c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A.b&lt;B.b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A.a&lt;B.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node A,node B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.b==B.b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.a==B.a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.c==B.c)</span><br><span class="line">                <span class="keyword">return</span> A.d&lt;B.d;</span><br><span class="line">            <span class="keyword">return</span> A.c&lt;B.c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A.a&lt;B.a;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A.b&lt;B.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp3</span><span class="params">(node A,node B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.c==B.c)&#123;</span><br><span class="line">		<span class="keyword">return</span> A.d&lt;B.d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A.c&lt;B.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[<span class="number">50009</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="keyword">return</span> p&amp;(-p);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> delta)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		t[i]=<span class="built_in">max</span>(t[i],delta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		res=<span class="built_in">max</span>(res,t[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		t[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">50009</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="comment">//a轴乱序，b轴排序</span></span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">CDQ2</span>(l,mid);</span><br><span class="line">	<span class="built_in">sort</span>(pt+l,pt+mid+<span class="number">1</span>,cmp3);</span><br><span class="line">	<span class="built_in">sort</span>(pt+mid+<span class="number">1</span>,pt+r+<span class="number">1</span>,cmp3);</span><br><span class="line">	<span class="type">int</span> L=l;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;=mid &amp;&amp; pt[i].c&gt;=pt[L].c)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pt[L].grd==<span class="number">0</span>)&#123;<span class="built_in">add</span>(pt[L].d,pt[L].ans);&#125;</span><br><span class="line">			L++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pt[i].grd==<span class="number">1</span>)</span><br><span class="line">			pt[i].ans=<span class="built_in">max</span>(pt[i].ans,pt[i].w+<span class="built_in">query</span>(pt[i].d));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=L;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pt[i].grd==<span class="number">0</span>) <span class="built_in">del</span>(pt[i].d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">		ls[pos2[pt[i].id]]=pt[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">		pt[i]=ls[i];</span><br><span class="line">    <span class="built_in">CDQ2</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">CDQ1</span>(l,mid);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)</span><br><span class="line">		pt[i].grd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">		pt[i].grd=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(pt+l,pt+r+<span class="number">1</span>,cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">		pos2[pt[i].id]=i;</span><br><span class="line">	<span class="built_in">CDQ2</span>(l,r);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">		ls[pos1[pt[i].id]]=pt[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">		pt[i]=ls[i];</span><br><span class="line">    <span class="built_in">CDQ1</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; s[i].a &gt;&gt; s[i].b &gt;&gt; s[i].c &gt;&gt; s[i].d;	</span><br><span class="line">		l[i]=s[i].d;</span><br><span class="line">		s[i].id=i;</span><br><span class="line">        s[i].w=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(l+<span class="number">1</span>,l+n+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">unique</span>(l+<span class="number">1</span>,l+n+<span class="number">1</span>)-l<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		s[i].d=<span class="built_in">lower_bound</span>(l+<span class="number">1</span>,l+len+<span class="number">1</span>,s[i].d)-l; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i].a==s[i<span class="number">-1</span>].a &amp;&amp; s[i].b==s[i<span class="number">-1</span>].b &amp;&amp; s[i].c==s[i<span class="number">-1</span>].c &amp;&amp; s[i].d==s[i<span class="number">-1</span>].d)</span><br><span class="line">			pt[tp].w+=s[i].w;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			pt[++tp]=s[i];</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(pt+<span class="number">1</span>,pt+tp+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tp;i++)&#123;</span><br><span class="line">        pt[i].id=i;</span><br><span class="line">        pt[i].ans=pt[i].w;</span><br><span class="line">		pos1[pt[i].id]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CDQ1</span>(<span class="number">1</span>,tp);</span><br><span class="line">    <span class="type">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        maxx=<span class="built_in">max</span>(maxx,pt[i].ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxx &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="cf1045g">CF1045G</h1>
<p>首先按照<span
class="math inline">\(r_i\)</span>降序排序，这样只用右边能看到左边就可以了。</p>
<p>再来考虑排完序后的 <span class="math inline">\(CDQ\)</span>
，乍一看可以左右分别按照 <span class="math inline">\(x_i\)</span>
排序，然后归并，然后每一次贡献都是一个前缀。</p>
<p>其实这样是不正确的，因为此时 <span class="math inline">\(r_i\)</span>
是乱序，可能在往右扫的过程中前缀是反复横跳状态，而归并只能从左往右，就寄了。</p>
<p>那么只好考虑以 <span class="math inline">\(q_i\)</span>
排序了，此时的状态是：<span
class="math inline">\(r_i\)</span>乱序，但所有左边的 <span
class="math inline">\(r_i\)</span> 一定大于右边的 <span
class="math inline">\(r_i\)</span>，然后左半边和右半边的 <span
class="math inline">\(q_i\)</span> 是分别排好序的。</p>
<p>那么对于右边的点，左边的可能可以贡献给他的点集就是一段连续的区间，这里可以发现，这个区间的端点一定是单调递增的，那么就可以愉快的双指针了。</p>
<p>还差一维，就是刚刚的<span
class="math inline">\(x_i\)</span>这一维度，可以考虑树状数组，就解决了。</p>
<p>注意要离散化。</p>
<h1 id="cf848c">CF848C</h1>
<p><del>绷不住了，竟然有二维分块做法，万万没想到。</del></p>
<p>如果用<span
class="math inline">\(CDQ\)</span>分治，那么首先这个贡献是需要差分的，考虑转换一下，变成求：
<span class="math display">\[
∑_{i=1}^R i−pre_{A_i}\ [pre_{A_i}\ &gt;=L]
\]</span> 那么我们可以把每一个 <span class="math inline">\(i\)</span>
看作是一个横坐标是 <span class="math inline">\(i\)</span> 纵坐标是 <span
class="math inline">\(pre_{A_i}\)</span>
的点，那么查询就是查询一个左上角矩形了。当然还要加上时间轴。</p>
<p>具体来说也就是：</p>
<ul>
<li><p><span class="math inline">\(i&lt;=R\)</span></p></li>
<li><p><span class="math inline">\(pre_{A_i}&gt;=L\)</span></p></li>
<li><p><span class="math inline">\(T[q[lr]]&gt;T[pt]\)</span></p></li>
<li><p>每个点的贡献是 <span
class="math inline">\(i-pre[a_i]\)</span></p></li>
</ul>
<p>三位偏序了，但是修改有点麻烦，可以考虑抵消上一次的点再加入新点。</p>
<p>然后再来考虑怎么三位偏序，首先按照时间维度排序，再把左右分别按照
<span class="math inline">\(i\)</span> 排序，然后再按照 <span
class="math inline">\(i\)</span> 归并一下，如果当前是左半边的 <span
class="math inline">\(i\)</span> ，就在树状数组的 <span
class="math inline">\(pre_{A_i}\)</span> 位置上加 <span
class="math inline">\(i-pre_{A_i}\)</span>。对于右半部分的一个询问，当前已经加入的节点的
<span class="math inline">\(i\)</span>值比他小满足条件 <span
class="math inline">\(1\)</span>，第二维就是一段树状数组的后缀查询求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100009</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],pre[N],nxt[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; S[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,prex,op,w;</span><br><span class="line">	<span class="type">int</span> b,c;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">&#125;e[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> tp;</span><br><span class="line"><span class="type">int</span> bit[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="keyword">return</span> p&amp;(-p);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> delta)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		bit[i]+=delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		bit[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> resr=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		resr+=bit[i];</span><br><span class="line">	<span class="type">int</span> resl=<span class="number">0</span>;</span><br><span class="line">	l--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		resl+=bit[i];</span><br><span class="line">	<span class="keyword">return</span> resr-resl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node A,node B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.op!=B.op) <span class="keyword">return</span> A.op&lt;B.op;</span><br><span class="line">	<span class="keyword">if</span>(A.op==<span class="number">1</span>) <span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> A.c&lt;B.c;</span><br><span class="line">	<span class="comment">//return A.x&lt;B.x;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> pla,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tp].op=<span class="number">1</span>;</span><br><span class="line">	e[tp].x=pla;</span><br><span class="line">	e[tp].prex=pre[pla];</span><br><span class="line">	e[tp].w=pre[pla]-pla;</span><br><span class="line">	pre[pla]=v;</span><br><span class="line">	e[++tp].op=<span class="number">1</span>;</span><br><span class="line">	e[tp].x=pla;</span><br><span class="line">	e[tp].prex=pre[pla];</span><br><span class="line">	e[tp].w=pla-pre[pla];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">CDQ</span>(l,mid);</span><br><span class="line">	<span class="built_in">CDQ</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="comment">//sort(e+l,e+mid+1,cmp1);</span></span><br><span class="line">	<span class="comment">//sort(e+mid+1,e+r,cmp1);</span></span><br><span class="line">	<span class="type">int</span> L=l;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(e[i].op!=<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;=mid &amp;&amp; (e[i].x&gt;=e[L].x || e[i].op==<span class="number">2</span>))&#123;</span><br><span class="line">			<span class="keyword">if</span>(e[i].op==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">add</span>(e[i].prex,e[i].w);</span><br><span class="line">			&#125;</span><br><span class="line">			L++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[e[i].id]+=<span class="built_in">query</span>(e[i].b,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=L;i++)</span><br><span class="line">		<span class="built_in">add</span>(e[i].prex,-e[i].w);</span><br><span class="line">	<span class="built_in">sort</span>(e+l,e+r+<span class="number">1</span>,cmp1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		set&lt;<span class="type">int</span>&gt;::iterator it=S[a[i]].<span class="built_in">lower_bound</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(it!=S[a[i]].<span class="built_in">end</span>()) pre[i]=*it;</span><br><span class="line">		set&lt;<span class="type">int</span>&gt;::iterator it2=S[a[i]].<span class="built_in">upper_bound</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(it2!=S[a[i]].<span class="built_in">end</span>()) nxt[i]=*it2;</span><br><span class="line">		S[a[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">		e[++tp].x=i,e[tp].prex=pre[i],e[tp].w=i-pre[i];</span><br><span class="line">		e[tp].op=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//e[tp].id=tp;不需要还原</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin &gt;&gt; e[++tp].op &gt;&gt; e[tp].b &gt;&gt; e[tp].c;</span><br><span class="line">		<span class="comment">//e[tp].id=tp;不需要还原</span></span><br><span class="line">		<span class="keyword">if</span>(e[tp].op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(e[tp].c==a[e[tp].b]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> PP,NN;</span><br><span class="line">			set&lt;<span class="type">int</span>&gt;::iterator it=S[a[i]].<span class="built_in">lower_bound</span>(i);</span><br><span class="line">			<span class="keyword">if</span>(it!=S[a[i]].<span class="built_in">end</span>()) PP=*it;</span><br><span class="line">			set&lt;<span class="type">int</span>&gt;::iterator it2=S[a[i]].<span class="built_in">upper_bound</span>(i);</span><br><span class="line">			<span class="keyword">if</span>(it!=S[a[i]].<span class="built_in">end</span>()) NN=*it2;</span><br><span class="line">			S[a[e[tp].b]].<span class="built_in">erase</span>(e[tp].b);</span><br><span class="line">			S[e[tp].c].<span class="built_in">insert</span>(e[tp].b);</span><br><span class="line">			nxt[pre[e[tp].b]]=nxt[e[tp].b];</span><br><span class="line">			nxt[PP]=e[tp].b;</span><br><span class="line">			<span class="built_in">change</span>(e[tp].b,PP);</span><br><span class="line">			nxt[e[tp].b]=NN;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CDQ</span>(<span class="number">1</span>,tp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tp;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[i])&#123;</span><br><span class="line">			cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="p4207-noi2007-货币兑换">P4207 [NOI2007] 货币兑换</h1>
<p>首先有一个理论上应该一眼的性质：要么不买，要么花光积蓄。</p>
<p>证明考虑如果我们买入部分，那么卖出的时候赚的钱就少了。</p>
<p><strong>这也提示我们类似这种每一次可以选择部分物品操作的题目，要思考思考有没有必要部分！</strong></p>
<p>那么我们每天的状态就是两个：</p>
<ul>
<li>身无分文，全是金券。</li>
<li>一夜暴富，没有金券。</li>
</ul>
<p>我们设 <span class="math inline">\(f_i\)</span> 为假如在 <span
class="math inline">\(i\)</span> 这一天没有金权最多能得到的钱。</p>
<p>那么我们转移可以从 <span class="math inline">\(f_{i-1}\)</span>
（什么也不干），或者 <span class="math inline">\(f_j\)</span>
（我在<span class="math inline">\(j\)</span>这一天买然后在 <span
class="math inline">\(i\)</span>这一天卖出）而来。</p>
<p><span class="math inline">\(x_i=f_i\times
\frac{R_i}{A_iR_i+B_i}\)</span></p>
<p><span class="math inline">\(y_i=f_i\times
\frac{1}{A_iR_i+B_i}\)</span></p>
<p><span class="math inline">\(f_i=max\)</span> {<span
class="math inline">\(f_{i-1},max\)</span> { <span
class="math inline">\(x_jA_i+y_jB_i\)</span> } }</p>
<p>后面的一堆似乎很斜率优化，于是考虑 <span
class="math inline">\(f_j\)</span> 什么时候优于 <span
class="math inline">\(f_k\)</span>。</p>
<p><span class="math inline">\(\frac{y_j-y_k}{x_j-x_k} \gt
-\frac{A_i}{B_i}\)</span></p>
<p>由于正负号问题，所以不能普通的斜率优化,所以考虑斜率优化，考虑用 <span
class="math inline">\(CDQ\)</span>分治，这样就能根据 <span
class="math inline">\(x\)</span>轴排序了，就能在左半边建立上凸壳再转移到右边了。</p>
<h1 id="bzoj2961-共点园">BZOJ2961 共点园</h1>
<p>咕咕。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">starslight</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
